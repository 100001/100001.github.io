<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>100001</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://100001.github.io/"/>
  <updated>2020-08-10T11:01:24.125Z</updated>
  <id>https://100001.github.io/</id>
  
  <author>
    <name>Zhongwen Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>极速解析（二）: 延迟解析（Lazy Parsing）</title>
    <link href="https://100001.github.io/2020/08/03/Blazingly-fast-parsing-part-2-lazy-parsing/"/>
    <id>https://100001.github.io/2020/08/03/Blazingly-fast-parsing-part-2-lazy-parsing/</id>
    <published>2020-08-03T11:11:32.000Z</published>
    <updated>2020-08-10T11:01:24.125Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原文→"><a href="#原文→" class="headerlink" title="原文→"></a><a href="https://v8.dev/blog/preparser" target="_blank" rel="noopener">原文→</a></h4><p>这是本系列文章的第二部分，介绍V8如何尽可能快地解析JavaScript。第一部分解释了我们如何使V8的<a href="/2020/08/03/Blazingly-fast-parsing-part-1-optimizing-the-scanner/">扫描器</a>更快。</p><p>解析是将源代码转换为中间代码的步骤，中间代码由编译器处理（在V8中，<a href="https://v8.dev/blog/ignition-interpreter" target="_blank" rel="noopener">Ignition</a>是字节码编译器）。解析和编译是在网页启动的关键路径上进行的，在启动过程中，并非所有发送到浏览器的函数都是立即必要的。虽然开发人员可以使用async和defer脚本来延迟这类代码，但这并不总是可行的。此外，许多web页面提供的代码仅供某些功能使用，而这些功能在页面单独运行的任何时候可能根本无法被用户访问。</p><p>非必要地主动（<a href="https://keqingrong.github.io/blog/2019-06-30-cs-words-2#eager" target="_blank" rel="noopener">eagerly</a>）编译代码会带来实际的资源开销：</p><ul><li>CPU周期被用于生成代码，对于启动实际需要的代码来说，耽误其可用性。</li><li>代码对象占用内存，至少直到当前不需要该代码并允许对其进行垃圾回收为止，才决定<a href="https://v8.dev/blog/v8-release-74#bytecode-flushing" target="_blank" rel="noopener">刷新字节码（bytecode flushing）</a>。</li><li>顶层脚本完成执行时，编译的代码最终缓存在磁盘上，从而占用磁盘空间。</li></ul><p>由于这些原因，所有主流浏览器都实现了<em>延迟解析（lazy parsing）</em>。解析器（parser）不必为每个函数生成一个抽象语法树（AST）且编译为字节码，也不必完全解析它们，而是“预解析（pre-parse）”它遇到的函数。它通过切换到<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/preparser.h?l=921&rcl=e3b2feb3aade83c02e4bd2fa46965a69215cd821" target="_blank" rel="noopener">预解析器（preparser）</a>来实现这一点，预解析器是解析器的一个副本，它只需做最少的工作就可以略过函数。预解析器验证它略过的函数在语法上是有效的，并生成外部函数编译正确所需的全部信息。之后，当调用预解析后的（preparsed）函数时，它将按需进行完全解析和编译。</p><h4 id="变量分配"><a href="#变量分配" class="headerlink" title="变量分配"></a>变量分配</h4><p>使预解析（pre-parsing）变得复杂的主要原因是变量分配。</p><p>出于性能原因，函数执行（activations）是在计算机的栈（stack）上进行管理。例如，假设函数<code>g</code>调用函数<code>f</code>，并传入参数<code>1</code>和<code>2</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> c = a + b;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// `f`的返回指令指针，现在指向此处</span></span><br><span class="line">  <span class="comment">// （因为当 `f` `return`时, 它返回这里）。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将接收器（即<code>f</code>的<code>this</code>值，这里是指全局的<code>this</code>（<code>globalThis</code>），因为它是一个粗略的函数调用）压入栈，紧接着是被调用的函数<code>f</code>。然后参数<code>1</code>和<code>2</code>被压入栈。此时函数<code>f</code>被调用。要执行该调用，我们首先在栈上保存<code>g</code>的状态：<code>f</code>的“返回指令指针（return instruction pointer）”（<code>rip</code>；我们需要返回的代码）以及“帧指针（frame pointer）”（<code>fp</code>；返回时栈的样子）。然后进入<code>f</code>，它为局部变量<code>c</code>分配空间，以及它可能需要的任何临时空间。这可以确保函数执行（activation）超出作用域时，函数使用的任何数据将消失：它只是简单地从栈中弹出。<br><img src="stack-1.svg" alt=""><br><font size=2>调用函数<code>f</code>的栈布局，以及分配到栈上的参数<code>a</code>、<code>b</code>和局部变量<code>c</code>。</font></p><p>这种设置的问题在于函数可以引用外部函数中声明的变量。内部函数可能在它们被创建激活（activation）后继续存在：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_f</span>(<span class="params">d</span>) </span>&#123; <span class="comment">// ← 声明 `d`</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c = a + b + d; <span class="comment">// ← 引用 `d`</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = make_f(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中，在<code>make_f</code>返回（return）后，将计算<code>make_f</code>中声明的从<code>inner</code>到局部变量<code>d</code>的引用。为了实现这一点，具有词法闭包（lexical closures）的语言的虚拟机（VMs）在一种名为“上下文（context）”的结构中分配变量，该变量存放在堆（heap）里，被内部函数所引用。<br><img src="stack-2.svg" alt=""><br><font size=2>调用<code>make_f</code>的栈布局。该调用将参数复制分配到一个在堆里的上下文中，然后供捕获<code>d</code>的<code>inner</code>使用。</font></p><p>这意味着，对于函数中声明的每个变量，我们需要知道内部函数是否引用该变量，这样我们就可以决定是把变量分配到栈上还是在已分配堆（heap-allocated）的上下文里。当我们计算函数字面量时，我们分配一个闭包，它既指向函数的代码，也指向当前上下文：该对象包含可能需要访问的变量值。</p><p>长话短说，我们至少需要跟踪预解析器中的变量引用。</p><p>如果我们只跟踪引用，我们会高估被引用的变量。在外部函数中声明的变量可能会被内部函数中的重新声明所覆盖，从而使来自该内部函数的引用以内部声明为目标，而不是外部声明。如果我们无条件地在上下文中分配外部变量，性能将受到影响。因此，为了使变量分配正确地与预解析（preparsing）一起工作，我们需要确保预解析后的（prepared）函数正确地跟踪变量引用和声明。</p><p>顶层代码是此规则的例外。脚本的顶层总是堆分配的，因为变量在脚本中是可见的。接近良好工作架构的一个简单方法是运行预解析器，但不使用变量跟踪来快速解析顶层函数；对内部函数使用完整的解析器，但略过编译。这比预解析（preparsing）成本高，因为我们非必要地建立了一棵完整的AST，但它使我们正常运行起来。这正是V8在V8 v6.3/Chrome 63上的表现。</p><h4 id="指导预解析器如何处理变量"><a href="#指导预解析器如何处理变量" class="headerlink" title="指导预解析器如何处理变量"></a>指导预解析器如何处理变量</h4><p>在预解析器中跟踪变量声明和引用是很复杂的，因为在JavaScript中，从一开始并不总是清楚片段表达式的含义。例如，假设我们有一个函数<code>f</code>，包含一个参数<code>d</code>，<code>f</code>有一个内部函数<code>g</code>，<code>g</code>里有一个表达式，看起来像是引用了<code>d</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = (&#123; d &#125;</span><br></pre></td></tr></table></figure><p>它可能最终引用<code>d</code>，因为我们看到的token是一个解构赋值表达式的一部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = (&#123; d &#125; = &#123; <span class="attr">d</span>: <span class="number">42</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它也可能最终成为一个带解构参数<code>d</code>的箭头函数，在这种情况下，<code>g</code>不会引用<code>f</code>中的<code>d</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="function">(<span class="params">&#123; d &#125;</span>) =&gt;</span> d;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [d, g];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初，我们的预解析器是作为解析器的独立副本实现的，没有太多的共享，这导致两个解析器随着时间的推移而不同。通过将解析器和预解析器重写为基于实现<a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_blank" rel="noopener">奇异递归模板模式</a>的<code>ParserBase</code>，我们设法最大限度地实现共享，同时保持单独副本的性能优势。这大大简化了向预解析器添加完整的变量跟踪，因为实现的大部分内容可以在解析器和预解析器之间共享。</p><p>实际上，忽略变量声明和引用，即使对于顶层函数也是不正确的。ECMAScript规范要求在第一次解析脚本时检测到各种类型的变量冲突。例如，假设一个变量在同一作用域内被两次声明为词法变量，则被认为是<a href="https://tc39.es/ecma262/#early-error" target="_blank" rel="noopener">早期语法错误</a>。由于预解析器只是略过了变量声明，所以在预解析（preparse）期间它会错误地允许代码通过。当时我们认为赢得性能是规范冲突的正当理由。但是，既然预解析器正确地跟踪了变量，我们就消除这类与变量解析相关的规范冲突，而不会造成显著的性能损失。</p><h4 id="略过内部函数"><a href="#略过内部函数" class="headerlink" title="略过内部函数"></a>略过内部函数</h4><p>如前所述，当第一次调用预解析后的（preparsed）函数时，我们完全解析它并将得到的AST编译为字节码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是顶层作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 预解析后的 preparsed</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 预解析后的 preparsed</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer(); <span class="comment">// 完全解析和编译 `outer`， 但不处理 `inner`。</span></span><br></pre></td></tr></table></figure><p>函数直接指向外部上下文，该上下文包含内部函数需要使用的变量声明的值。为了允许延迟编译函数（并支持调试器），上下文指向一个名为<a href="https://cs.chromium.org/chromium/src/v8/src/objects/scope-info.h?rcl=ce2242080787636827dd629ed5ee4e11a4368b9e&l=36" target="_blank" rel="noopener">ScopeInfo</a>的元数据对象。<code>ScopeInfo</code>对象描述上下文中列出的变量。这意味着在编译内部函数时，我们可以计算变量在上下文链中的位置。</p><p>但是，要计算延迟编译函数本身是否需要上下文，我们需要再次执行作用域解析：我们需要知道嵌套在延迟编译函数中的函数是否引用延迟函数声明的变量。我们可以通过重新预解析（re-preparsing）这些函数来解决这个问题。这正是V8在V8 v6.3/Chrome 63上的表现。不过，这并不是理想的性能，因为它使源码大小和解析开销之间的关系变得非线性：我们预解析（preparse）函数的次数将会与嵌套函数的个数一样多。除了动态程序的自然嵌套之外，JavaScript打包程序通常将代码包装在“<a href="https://en.wikipedia.org/wiki/Immediately_invoked_function_expression" target="_blank" rel="noopener">立即调用函数表达式</a>”（IIFEs）中，这使得大多数JavaScript程序具有多个嵌套层。<br><img src="parse-complexity-before.svg" alt=""><br><font size=2>每次重新解析至少都增加了解析函数的开销。</font></p><p>为了避免非线性的性能开销，我们甚至在预解析（preparsing）过程中执行全作用域解析。我们存储了足够的元数据，以便之后可以简单地略过内部函数，而不必重新预解析（re-preparse）它们。一种方法是存储内部函数引用的变量名。这是昂贵的存储，并仍然要求我们重复工作：我们已经在预解析（preparse）期间执行了变量解析。</p><p>相反，我们序列化分配变量的地址，如同一个标记每个变量的密集数组。当我们延迟解析一个函数时，将按照预解析器看到它们的顺序重新创建变量，并且我们可以简单地将元数据应用于变量。既然已经编译了函数，就不再需要变量分配元数据，并且可以对其进行垃圾回收。由于我们只需要这些元数据用于实际上包含内部函数的函数，因此所有函数中的很大一部分甚至都不需要此元数据，从而大大减少了内存开销。<br><img src="parse-complexity-after.svg" alt=""><br><font size=2>通过跟踪预解析后的（preparsed）函数的元数据，我们可以完全略过内部函数。</font></p><p>与重新预解析（re-preparsing）内部函数的开销一样，略过内部函数的性能影响是非线性的。有些网站将其所有函数提升到顶层作用域。由于它们的嵌套级别始终为0，因此开销始终为0。然而，许多现代网站实际上都有很深的嵌套函数。当这个功能在v8 v6.3/chrome 63中发布时，在这些网站上，我们看到了显著的改进。主要的优点是现在代码的嵌套程度已经不再重要了：任何函数最多只预解析（preparsed）一次，以及完全解析一次<a href="#fn1">[1]</a>。<br><img src="skipping-inner-functions.svg" alt=""><br><font size=2>主线程和脱离主线程的解析时间，启动前后“略过内部函数”优化。</font></p><h4 id="可能调用函数表达式"><a href="#可能调用函数表达式" class="headerlink" title="可能调用函数表达式"></a>可能调用函数表达式</h4><p>如前所述，打包程序通常将多个模块合并到一个文件中，方法是将模块代码封装在一个立即调用的闭包中。这为模块提供了隔离，允许它们像脚本中唯一的代码一样运行。这些函数本质上是嵌套脚本；这些函数在脚本执行时立即调用。打包程序通常会将<em>立即调用函数表达式</em>（IIFEs；发音为“iffies”）转换为括号函数：<code>(function(){…})()</code>。</p><p>由于这些函数在脚本执行期间是立即需要的，所以预解析（preparse）这些函数有点不理想。在顶层的脚本执行过程中，我们需要立即编译函数，并对函数进行完全解析和编译。这意味着，我们之前为了加速启动而进行的更快的解析，肯定会给启动带来不必要的额外开销。</p><p>你可能会问，为什么不简单地编译被调用的函数呢？虽然开发人员通常会直接注意到函数何时被调用，但解析器却不是这样。解析器需要在开始解析一个函数之前做出决定，是主动（eagerly）编译函数还是推迟编译。语法中的模糊性使简单地快速扫描到函数末尾变得困难，而且开销很快与常规预解析（preparsing）相似。</p><p>由于这个原因，V8有两个简单的模式，可以将其识别为<em>可能调用函数表达式</em>（PIFEs；发音为“piffies”），并在其上主动（eagerly）解析和编译函数：</p><ul><li>如果一个函数是括号函数表达式，即<code>(function(){…})</code>，我们假设它将被调用。我们一看到这种模式的开始就做出这个假设，也就是<code>(function</code>。</li><li>从v8 v5.7/Chrome 57开始，我们还检测这种由<a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="noopener">UglifyJS</a>生成的模式<code>!function(){…}(),function(){…}(),function(){…}()</code>。我们一旦看到<code>!function</code>或者<code>function</code>就开始这种检测，如果它跟随一个PIFE。</li></ul><p>由于V8主动（eagerly）编译PIFEs，因此它们可以用作<a href="https://en.wikipedia.org/wiki/Profile-guided_optimization" target="_blank" rel="noopener">概要导向反馈（profile-directed feedback）</a><a href="#fn2">[2]</a>，通知浏览器启动需要哪些函数。</p><p>在V8仍然重新解析内部函数的时候，一些开发人员已经注意到JS解析对启动的影响非常大。<a href="https://github.com/nolanlawson/optimize-js" target="_blank" rel="noopener">optimize-js</a>基于静态启发法（static heuristics）将函数转换为PIFEs。在创建包时，这对V8上的负载性能产生了巨大的影响。我们复制了<code>optimize-js</code>提供的在v8 v6.1上运行的基准测试结果，只查看精简后的脚本。<br><img src="eager-parse-compile-pife.svg" alt=""><br><font size=2>主动（eagerly）解析和编译PIFEs会使冷启动和热启动稍微快一些（第一和第二页加载，测量总的解析+编译+执行时间）。但是，由于对解析器的显著改进，v8 v7.5上的优势要比v8 v6.1上的小得多。</font></p><p>尽管如此，现在我们不再重新解析内部函数，而且由于解析器速度更快，所以通过<code>optimize-js</code>获得的性能改进将大大降低。实际上，v7.5的默认配置已经比运行在v6.1上的优化版本快得多。即使在v7.5上，对于启动期间需要的代码，谨慎地使用PIFEs仍然是有意义的：我们避免预解析（preparse)，因为我们很早就知道将需要该函数。</p><p><code>optimize-js</code>基准测试结果并不完全反映实际情况。脚本是同步加载的，整个解析+编译时间都计入加载时间。在实际设置中，你可能会使用&lt;script&gt;标签加载脚本。这使得Chrome的预加载程序能够在脚本被求值（evaluated）之前发现它，并在不阻塞主线程的情况下下载、解析和编译脚本。我们决定主动（eagerly）编译的所有内容都会自动脱离主线程进行编译，并且应该只在最小程度上计入启动时间。运行非主线程脚本编译会放大使用PIFEs的影响。</p><p>然而仍旧有成本，尤其是内存成本，因此主动（eagerly）编译所有内容不是一个好主意：<br><img src="eager-compilation-overhead.svg" alt=""><br><font size=2>主动（eagerly）编译所有JavaScript都要付出巨大的内存开销。</font></p><p>虽然在启动过程中为需要的函数加上括号是一个好主意（例如，基于概要（profiling）启动），但是使用像<code>optimize-js</code>这样的包应用简单的静态启发法并不是一个好主意。例如，假设一个函数如果它作为另一个函数调用的参数，则在启动期间它将被调用。但是，如果这样一个函数实现了整个模块，且该模块很长时间后才需要使用，那么最终编译的代码就太多了。过度主动（eagerly）编译对性能不利：没有延迟编译的V8显著地减少了加载时间。此外，<code>optimize-js</code>的一些好处来自于UglifyJS和其它压缩工具（minifiers）的问题，它们删除了非IIFEs的PIFEs的括号，以及删除有用的提示，这些提示本可以应用于例如<a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">通用模块定义（UMD）</a>风格的模块。这很可能是压缩工具（minifiers）应该修复的问题，以便在主动（eagerly）编译PIFEs的浏览器上获得最大性能。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>延迟解析加快了启动速度，并减少了应用程序的内存开销（发送的代码超出了它们的需要）。对于准确地（根据规范）和快速地进行预解析（preparse），能够正确地跟踪预解析器中的变量声明和引用是必要的。在预解析器中分配变量还允许我们序列化变量分配信息，以便稍后在解析器中使用，这样我们就可以避免完全重新预解析（re-preparse）内部函数，从而避免深层嵌套函数的非线性解析行为。</p><p>在启动过程中，解析器可以识别的PIFEs，对于立即需要的代码，能够避免初始化预解析（preparse）的开销。谨慎地概要引导（profile-guided ）使用PIFEs，或者由打包程序使用，可以提供有用的冷启动减速带。然而，应该避免不必要地在括号中封装函数来触发这个启发法，因为它会导致更多的代码被主动（eagerly）编译，从而导致更差的启动性能和更多的内存使用。</p><hr><ol><li>由于内存的原因，V8在一段时间未使用时，会<a href="https://v8.dev/blog/v8-release-74#bytecode-flushing" target="_blank" rel="noopener">刷新字节码</a>。如果这些代码最终在以后还需要，我们会重新解析并编译。由于我们允许变量元数据在编译过程中失效，所以在延迟重新编译时会引起内部函数的重新解析。不过这时我们会重新创建其内部函数的元数据，所以我们不需要再重新预解析（re-preparse）其内部函数的内部函数。<a name="fn1">[↩︎]</a></li><li>PIFEs也可以被认为是一个概要信息函数表达式（profile-informed function expressions.）。<a name="fn2">[↩︎]</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;原文→&quot;&gt;&lt;a href=&quot;#原文→&quot; class=&quot;headerlink&quot; title=&quot;原文→&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://v8.dev/blog/preparser&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文→&lt;/a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>极速解析（一）: 优化扫描器</title>
    <link href="https://100001.github.io/2020/08/03/Blazingly-fast-parsing-part-1-optimizing-the-scanner/"/>
    <id>https://100001.github.io/2020/08/03/Blazingly-fast-parsing-part-1-optimizing-the-scanner/</id>
    <published>2020-08-02T16:28:09.000Z</published>
    <updated>2020-08-03T07:02:07.600Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原文→"><a href="#原文→" class="headerlink" title="原文→"></a><a href="https://v8.dev/blog/scanner" target="_blank" rel="noopener">原文→</a></h4><p>要运行JavaScript程序，需要处理源代码文本，以便V8能够理解它。V8首先将源代码解析为一棵抽象语法树（AST），这是一组表示程序结构的对象。然后AST被<a href="https://v8.dev/blog/ignition-interpreter" target="_blank" rel="noopener">Ignition</a>编译成字节码。这些解析+编译阶段的性能非常重要：V8在编译完成之前不能运行代码。在这一系列的博客文章中，我们将重点放在解析上，以及V8实现的快速解析器所完成的工作。</p><p>实际上，我们在解析器之前的一个阶段就开始了这个系列。V8的解析器读取的“tokens”是由“扫描器”提供的。Token是由若干具有单一语义含义的字符组成的块：字符串、标识符、运算符（例如：<code>++</code>）。扫描器通过组合底层字符流中的连续字符来构造这些tokens。</p><p>扫描器读取的是一串Unicode字符流。这些Unicode字符总是从UTF-16<a href="https://stackoverflow.com/questions/27331819/whats-the-difference-between-a-character-a-code-point-a-glyph-and-a-grapheme" target="_blank" rel="noopener">代码单元</a>流中解码。我们之所以只支持UTF-16编码规范，是为了避免对各种编码规范进行区分或定制化的扫描解析，同时这也是JavaScript字符串的编码规范，且源代码定位依赖于该编码规范。<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.h?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=46" target="_blank" rel="noopener"><code>UTF16CharacterStream</code></a>提供一种（可能被缓冲）UTF-16编码的方式来兼容底层Latin1、UTF-8或UTF-16编码，这些编码通过Chrome从网络上获取再传递给V8。除了支持多种编码规范外，扫描器和字符流的分离允许V8透明地扫描，就好像整个数据源是可用的一样，即使到目前为止我们可能只通过网络接收到部分数据。<br><img src="overview.svg" alt=""></p><p>在扫描器和字符流之间的接口是一个命名为<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.h?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=54" target="_blank" rel="noopener"><code>Utf16CharacterStream::Advance()</code></a>的方法，它返回下一个UTF-16代码单元，或者返回-1表示输入结束。一个UTF-16代码单元不能对每个Unicode字符进行编码。<a href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane" target="_blank" rel="noopener">基本多语言平面</a>之外的字符编码是两个代码单元，也称为代理对。不过，扫描器操作的是Unicode字符，而不是UTF-16代码单元，因此它将这个底层流接口封装在<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.h?sq=package:chromium&g=0&rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=569" target="_blank" rel="noopener"><code>Scanner::Advance()</code></a>方法中，该方法将UTF-16代码单元解码为完整的Unicode字符。当前解码的字符由<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.cc?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=775" target="_blank" rel="noopener"><code>Scanner::ScanString()</code></a>这样的扫描方法缓冲并取走。</p><p>扫描器根据最多4个字符（JavaScript中最长的模糊字符序列<a href="#fn1">[1]</a>）<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.cc?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=422" target="_blank" rel="noopener">选择</a>特定的扫描器方法或token。一旦选择了像<code>ScanString</code>这样的方法，它将处理该token的剩余字符，并为下一个扫描的token（非当前token的一部分）缓冲第一个字符。<code>ScanString</code>还将扫描的字符复制到编码为Latin1或UTF-16的缓冲区中，同时解码转义序列。</p><h4 id="空白符（Whitespace）"><a href="#空白符（Whitespace）" class="headerlink" title="空白符（Whitespace）"></a>空白符（Whitespace）</h4><p>Token可以用不同类型的空白符隔开，例如换行符、空格键、制表符、单行注释、多行注释等。一种类型的空白符后可以跟其他类型的空白符。如果添加空白符导致两个token之间出现换行，则可能<a href="https://tc39.es/ecma262/#sec-automatic-semicolon-insertion" target="_blank" rel="noopener">自动插入分号</a>。因此，在扫描下一个token之前，将略过所有空白符，并记录新的换行。大多数实际的JavaScript代码是被精简的，所以多个空白符并不常见。因此，V8统一独立地扫描每种类型的空白符，就好像它们是普通的token一样。例如，假设token的第一个字符是<code>/</code>，然后紧挨着另一个<code>/</code>，V8会将其扫描为单行注释，并返回<code>Token::WHITESPACE</code>。循环持续扫描，<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.cc?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=671" target="_blank" rel="noopener">直到</a>找出非<code>Token::WHITESPACE</code>的token。这意味着，如果下一个token之前没有空白符，我们将立即开始扫描相关的token，而不需要显式地检查空白符。</p><p>然而，循环本身会增加每次扫描token的开销：它需要一个分支来验证刚扫描的结果。如果我们刚刚扫描的token是<code>Token::WHITESPACE</code>，则最好继续循环。反之我们就应该跳出循环。实现这些，我们是通过将循环本身放到一个的单独的<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/scanner-inl.h?rcl=d62ec0d84f2ec8bc0d56ed7b8ed28eaee53ca94e&l=178" target="_blank" rel="noopener">辅助方法</a>中，该方法在确定不是<code>Token::WHITESPACE</code>token后，就直接返回token。尽管这类修改看起来很小，但它们消除了每次扫描token的开销。对于像标点符号这样的短token来说，尤其有效：<br><img src="punctuation.svg" alt=""></p><h4 id="标识符扫描"><a href="#标识符扫描" class="headerlink" title="标识符扫描"></a>标识符扫描</h4><p><a href="https://tc39.es/ecma262/#prod-Identifier" target="_blank" rel="noopener">标识符</a>是最复杂也是最常见的token，它用于JavaScript中的变量名（以及其它作用）。标识符以一个Unicode字符开头，并具有<a href="https://cs.chromium.org/chromium/src/v8/src/unicode.cc?rcl=d4096d05abfc992a150de884c25361917e06c6a9&l=807" target="_blank" rel="noopener"><code>ID_Start</code></a>属性，之后的字符序列是可选地，并具有<a href="https://cs.chromium.org/chromium/src/v8/src/unicode.cc?rcl=d4096d05abfc992a150de884c25361917e06c6a9&l=947" target="_blank" rel="noopener"><code>ID_Continue</code></a>属性。查看一个Unicode字符是否具有<code>ID_Start</code>或<code>ID_Continue</code>属性是非常消耗性能的。通过插入一个从字符到其属性的映射缓存，我们可以稍微加快速度。</p><p>虽然大多数JavaScript源代码是使用ASCII字符编写的。但在ASCII字符范围中，只有<code>a-z</code>，<code>A-Z</code>，<code>$</code>和<code>_</code>是标识符的起始字符。<code>ID_Continue</code>额外的包括<code>0-9</code>。我们通过创建一个表为128个ASCII字符中的每一个添加标记，识别是<code>ID_Start</code>字符，还是<code>ID_Continue</code>字符等，从而加速标识符扫描。当我们要查看的字符在ASCII范围内时，我们在这个表中查找对应的标记，并用一个单独的分支验证属性。直到我们找到第一个没有<code>ID_Continue</code>属性的字符之前，字符都是标识符的一部分。</p><p>本文中提到的所有改进加起来，在标识符扫描性能方面存在以下差异：<br><img src="identifiers-1.svg" alt=""></p><p>较长的标识符扫描速度更快，这点似乎有违直觉。这可能会使你认为增加标识符长度有利于提升性能。在MB/s这个维度上，扫描较长的标识符肯定更快，因为我们在一个非常紧密的循环中停留的时间更长，而没有返回解析器。但是，从应用程序性能的角度来看，你关注的是扫描全部token的速度。下图大致展示了每秒扫描的token数与token长度的关系：<br><img src="identifiers-2.svg" alt=""></p><p>这里很明显，使用较短的标识符对应用程序的解析性能是有益的：每秒我们能够扫描更多的token。这意味着，以MB/s作为衡量维度的站点看起来解析更快但信息密度较低，即实际上每秒生成的token更少。</p><h4 id="内化精简标识符（Internalizing-minified-identifiers）"><a href="#内化精简标识符（Internalizing-minified-identifiers）" class="headerlink" title="内化精简标识符（Internalizing minified identifiers）"></a>内化精简标识符（Internalizing minified identifiers）</h4><p>在扫描程序和解析器的边界上，所有字符串字面量和标识符都将删除重复数据。如果解析器请求字符串或标识符的值，对于每个可能的文本值，解析器将收到一个唯一的字符串对象。这通常需要一个哈希表来查找。由于JavaScript代码经常被精简，因此V8对单一的ASCII字符串使用简单的查询表。</p><h4 id="关键字（Identifier-scanning）"><a href="#关键字（Identifier-scanning）" class="headerlink" title="关键字（Identifier scanning）"></a>关键字（Identifier scanning）</h4><p>关键字是由编程语言定义的标识符的特殊子集，例如<code>if</code>、<code>else</code>和<code>function</code>。V8的扫描器返回的关键字token与标识符不同。扫描标识符后，我们需要识别该标识符是否是关键字。由于JavaScript中的所有关键字只包含小写字符a-z，所以我们还保留了一些标记，用来表明ASCII字符是否可能是关键字start和continue字符。</p><p>如果一个标识符根据标记可能是关键字，我们可以通过匹配标识符的第一个字符来找到候选关键字的子集。第一个字符比关键字的长度更独特，因此减少了后续条件分支的数量。对于每个字符，我们基于可能的关键字长度进行条件判断，并且只在长度相等的情况下再将标识符与关键字进行比较。</p><p>更好的方法是使用一种名为<a href="https://en.wikipedia.org/wiki/Perfect_hash_function" target="_blank" rel="noopener">完美哈希</a>的技术。由于关键字列表是静态的，我们可以计算出一个完美的哈希函数，对于每个标识符该函数最多只能给我们一个候选关键字。V8使用<a href="https://www.gnu.org/software/gperf/" target="_blank" rel="noopener">gperf</a>来计算这个函数。<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/keywords-gen.h" target="_blank" rel="noopener">结果</a>是根据标识符的长度和前两个字符计算出哈希，用来找到唯一候选关键字。只有当关键字的长度与输入标识符的长度匹配时，我们才比较标识符和关键字。这尤其加快了识别出标识符不是关键字的情况，因为我们只需要较少的条件分支来判断它。<br><img src="keywords.svg" alt=""></p><h4 id="代理对（Surrogate-pairs）"><a href="#代理对（Surrogate-pairs）" class="headerlink" title="代理对（Surrogate pairs）"></a><a href="https://baike.baidu.com/item/surrogate%20pair" target="_blank" rel="noopener">代理对（Surrogate pairs）</a></h4><p>如前所述，我们的扫描器工作在UTF-16编码的字符流上，但处理的是Unicode字符。<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84" target="_blank" rel="noopener">补充平面</a>中的字符只对标识符token有特殊意义。例如，假设这样的字符出现在字符串中，它们不会终止字符串。JS支持单个代理（Lone Surrogates），并且只从源代码复制。因此，除非绝对必要，最好避免组合代理对，并让扫描器直接对UTF-16代码单元进行操作而不是Unicode字符。当我们扫描一个字符串时，我们不需要寻找代理对，组合它们，然后在我们构建文本时再次拆分存储的字符。扫描器只剩下两个地方需要处理代理对。在token扫描开始时，只有当我们不能将识别某个字符时，才需要<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/scanner-inl.h?rcl=d4096d05abfc992a150de884c25361917e06c6a9&l=515" target="_blank" rel="noopener">组合</a>代理对用来检查结果是否是标识符开始。类似地，在处理非ASCII字符的标识符扫描的慢路径中，我们需要<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/scanner.cc?rcl=d4096d05abfc992a150de884c25361917e06c6a9&l=1003" target="_blank" rel="noopener">组合</a>代理对。</p><h4 id="AdvanceUntil"><a href="#AdvanceUntil" class="headerlink" title="AdvanceUntil"></a>AdvanceUntil</h4><p>扫描器和<code>UTF16CharacterStream</code>之间的接口边界是有状态的。流会记录它在缓冲区中的位置，在处理完每个代码单元之后，位置随之递增。在扫描器再次调用请求字符的扫描方法之前，会先缓冲一个已接收的代码单元。那个扫描方法读取缓冲的字符并且基于字符的值继续执行。这提供了很好的分层，但相当慢。去年秋天，我们的实习生Florian Sattler提出了一个改进的接口，它既保留了分层的优点，又能够在流中更快的访问代码单元。一个模板化的函数<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/scanner.h?rcl=d4096d05abfc992a150de884c25361917e06c6a9&l=72" target="_blank" rel="noopener"><code>AdvanceUntil</code></a>，专门用于特定的扫描辅助函数，在流中每个字符都调用该辅助函数，直到辅助函数返回<code>false</code>。这本质上为扫描器提供了对底层数据的直接访问，而不会破坏抽象。它实际上简化了扫描辅助函数，因为它们不需要处理<code>EndOfInput</code>。<br><img src="advanceuntil.svg" alt=""></p><p><code>AdvanceUntil</code>对于加速可能需要消耗大量字符的扫描函数特别有用。我们用它来加速前面已经提到的标识符，以及字符串<a href="#fn2">[2]</a>和注释。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>扫描性能是解析器性能的基石。我们已经调整了扫描器，使之尽可能的高效。这导致了全面的改进，单token扫描的性能提高了大约1.4倍，字符串扫描提高了1.3倍，多行注释扫描提高了2.1倍，标识符扫描提高了1.2–1.5倍，这取决于标识符的长度。</p><p>我们的扫描器只能做这么多。作为开发人员，你可以通过增加程序的信息密度来进一步提高解析性能。最简单的方法是精简源代码，去掉不必要的空白符，并尽可能避免非ASCII标识符。理想情况下，这些步骤作为构建过程的一部分是自动化的，在这种情况下，编写代码时不必担心它。</p><hr><ol><li><code>&lt;!--</code>是HTML注释的开始，而<code>&lt;!-</code>扫描为“小于”、“非”、“减”。<a name="fn1">[↩︎]</a></li><li>不能用Latin1编码的字符串和标识符目前比较消耗性能，因为我们首先尝试将它们作为Latin1进行缓冲，一旦遇到不能用Latin1编码的字符，就将它们转换成UTF-16。<a name="fn2">[↩︎]</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;原文→&quot;&gt;&lt;a href=&quot;#原文→&quot; class=&quot;headerlink&quot; title=&quot;原文→&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://v8.dev/blog/scanner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文→&lt;/a&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2019 JavaScript的开销</title>
    <link href="https://100001.github.io/2020/07/29/The-Cost-of-JavaScript-in-2019/"/>
    <id>https://100001.github.io/2020/07/29/The-Cost-of-JavaScript-in-2019/</id>
    <published>2020-07-29T03:03:44.000Z</published>
    <updated>2020-07-30T05:57:58.909Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原文→"><a href="#原文→" class="headerlink" title="原文→"></a><a href="https://v8.dev/blog/cost-of-javascript-2019" target="_blank" rel="noopener">原文→</a></h4><blockquote><p>注意：如果你喜欢看演示文稿而不是阅读文章，那么请欣赏下面的视频！如果不是，跳过视频继续阅读。</p></blockquote><iframe width="560" height="315" src="https://www.youtube.com/embed/X9eRLElSW1c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><font size=2>“JavaScript的开销”由Addy Osmani在2019#PerfMatters大会上发表。</font></p><p>在过去几年里，JavaScript开销的一大变化是浏览器解析和编译脚本的速度有所提升。<strong>在2019年，处理脚本的主要开销是下载和CPU执行时间。</strong></p><p>如果浏览器的主线程忙于执行JavaScript，那么用户交互可能会延迟，因此优化脚本执行时间和网络的瓶颈可能会很有效果。</p><h4 id="可行的高级方案"><a href="#可行的高级方案" class="headerlink" title="可行的高级方案"></a>可行的高级方案</h4><p>这对web开发人员意味着什么？解析和编译开销不再像我们曾经认为的那样慢。JavaScript打包（bundle）需要关注的三件事是：</p><blockquote><p>译者注：对于bundle这个单词，在不同的上下文中，目前没有找到一个通用的中文词汇来翻译，因此直接用bundle也许更方便理解（类似的单词还包括chunk，worker等）</p></blockquote><ul><li><strong>减少下载时间</strong><ul><li>保持较小的JavaScript bundle，尤其是对于移动设备。体积小的bundle能够提高下载速度，降低内存使用率，并减少CPU消耗。</li><li>避免只有一个大的bundle；如果一个bundle超过50–100 kB，请将其拆分为独立且较小的bundle。（使用HTTP/2的多路复用，可以同时传递多个请求和响应消息，从而减少额外请求的开销。）</li><li>在移动设备上，由于网络速度的原因，你不希望过多的传输，而且还要保持低内存使用率。</li></ul></li><li><strong>改进执行时间</strong><ul><li>避免<a href="https://w3c.github.io/longtasks/" target="_blank" rel="noopener">耗时的任务</a>，因为这些任务会使主线程持续繁忙，并且会阻碍页面交互的速度。下载后，脚本执行时间现在是主要的开销。</li></ul></li><li><strong>避免使用大体积的内联脚本</strong>（因为它们仍然在主线程上被解析和编译）。一个好的经验法则是：如果脚本超过1KB，请避免内联它（这也是因为外部脚本的代码缓存起始于1KB）。</li></ul><h4 id="为什么下载和执行时间很重要？"><a href="#为什么下载和执行时间很重要？" class="headerlink" title="为什么下载和执行时间很重要？"></a>为什么下载和执行时间很重要？</h4><p>为什么优化下载和执行时间很重要？对于低速网络，下载时间至关重要。尽管4G（甚至5G）在世界各地都在增长，但我们的<a href="https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType" target="_blank" rel="noopener">有效连接类型</a>仍然不一致，因为我们中的许多人在旅途中遇到了感觉像3G（或更糟）的速度。</p><p>JavaScript的执行时间对于CPU速度慢的手机很重要。由于CPU、GPU和温控调频的不同，高端和低端手机的性能存在巨大差异。这对JavaScript的性能很重要，因为执行是受CPU限制的。</p><p>事实上，在Chrome这样的浏览器中，页面加载所花费的总时间中，有多达30%的时间用于JavaScript的执行。下图是在高端台式机上加载一个具有典型工作负载网站的页面（Reddit.com）：<br><img src="reddit-js-processing.svg" alt=""><br><font size=2>在V8中，JavaScript的执行过程占页面加载阶段所用时间的10-30%。</font></p><p>在移动设备上，与高端设备（Pixel 3）相比，中端手机（Moto G4）执行Reddit JavaScript的时间要长3-4倍，而在低端设备（低于100美元的Alcatel 1X）上，执行时间超过6倍：<br><img src="reddit-js-processing-devices.svg" alt=""><br><font size=2>Reddit的JavaScript在不同分类的设备（低端、普通和高端）上的耗时开销</font></p><blockquote><p>注意：Reddit在桌面端和移动端网页上有不同的体验，因此MacBook Pro的结果无法与其他结果进行比较。</p></blockquote><p>当你试图优化JavaScript的执行时间时，请注意可能会长期独占UI线程的<a href="https://web.dev/long-tasks-devtools/" target="_blank" rel="noopener">长任务</a>。即使页面看起来已经准备好了，也可以阻止关键任务的执行。把这些分解成更小的任务。通过拆分代码并确定加载顺序的优先级，你可以更快地让页面交互，并有望降低输入延迟。<br><img src="long-tasks@2x.png" alt=""><br><font size=2>长任务占据了主线程。你应该把它们分开。</font></p><h4 id="V8在改进解析-编译方面做了什么？"><a href="#V8在改进解析-编译方面做了什么？" class="headerlink" title="V8在改进解析/编译方面做了什么？"></a>V8在改进解析/编译方面做了什么？</h4><p>V8中的原始JavaScript解析速度比chrome60提高了2倍。同时，由于Chrome中的其他并行优化工作，原始解析（和编译）开销变得不那么明显/重要。</p><p>通过在Worker线程上解析和编译，V8平均减少了40%的主线程解析和编译工作量（例如，Facebook减少了46%，Pinterest减少了62%），最大的改进达到81%（YouTube）。这是对现有非主线程流式解析/编译的补充。<br><img src="chrome-js-parse-times.svg" alt=""><br><font size=2>不同版本的V8解析时间</font></p><p>我们还可以在Chrome发布的不同V8版本中可视化这些变化对CPU时间的影响。在Chrome61解析Facebook JS的同等时间内，现在Chrome75可以同时解析Facebook的JS和6倍Twitter的JS。<br><img src="js-parse-times-websites.svg" alt=""><br><font size=2>在Chrome61解析Facebook的JS时，Chrome75现在可以同时解析Facebook的JS和6倍Twitter的JS。</font></p><p>让我们深入了解这些变化是如何解锁的。简而言之，脚本资源可以在Worker线程上进行流式解析和编译，这意味着：</p><ul><li>V8可以解析+编译JavaScript而不阻塞主线程。</li><li>当完整的HTML解析器遇到&lt;script&gt;标签时，流解析就开始了。对于解析器阻塞脚本，HTML解析器暂停，而对于异步脚本则继续。</li><li>对于大多数实际的连接速度，V8的解析速度比下载快，因此V8在最后一个脚本字节下载后几毫秒内完成解析+编译。</li></ul><p>不那么简短的解释是…Chrome的老版本会在开始解析脚本之前下载完整的脚本，这是一种简单的方法，但它没有充分利用CPU。在41到68版本之间，一旦下载开始，Chrome就开始在一个单独的线程上解析async和defer脚本。<br><img src="script-streaming-1.svg" alt=""><br><font size=2>脚本以多个chunk的形式下载到浏览器。V8在接收到至少30kB时开始流式解析。</font></p><p>在Chrome71中，我们转向了基于任务的设置，在这种设置中，调度器可以同时解析多个async/defer脚本。这一变化的好处是主线程解析时间减少了约20%，根据实际网站的测量，TTI（Time To Interactive）/FID（First Input Delay）总体上提高了约2%。<br><img src="script-streaming-2.svg" alt=""><br><font size=2>Chrome71迁移到基于任务的设置中，调度器可以同时解析多个async/defer脚本。</font></p><p>在Chrome72中，我们切换到使用流作为主要的解析方式：现在也可以用这种方式解析常规的同步脚本（虽然不是内联脚本）。如果主线程需要的话，我们也停止了取消基于任务的解析，因为这会不必要地重复已经完成的任何工作。</p><p><a href="https://v8.dev/blog/v8-release-75#script-streaming-directly-from-network" target="_blank" rel="noopener">Chrome以前的版本</a>支持流式解析和编译，其中来自网络的脚本源数据必须先到达Chrome的主线程，然后才能转发到流处理器（streamer）。</p><p>这通常会导致流式解析器等待，因为主线程上的其他工作（如HTML解析、布局或JavaScript执行）阻塞了已经从网络下载的数据转发到流任务。</p><p>我们现在正尝试性的在预加载时开始解析，而main-thread-bounce（主线程回弹）在这之前会阻塞。</p><p>Leszek Swirski’s BlinkOn 演示呈现了更多细节:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/D1UJgiG4_NI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h4 id="这些变化如何反映你在DevTools中看到的内容？"><a href="#这些变化如何反映你在DevTools中看到的内容？" class="headerlink" title="这些变化如何反映你在DevTools中看到的内容？"></a>这些变化如何反映你在DevTools中看到的内容？</h4><p>除上述之外，DevTools中有个问题，它在呈现整个解析器任务时示意自己正在使用CPU（完全阻塞）。因此，每当解析器需要数据（需要遍历主线程）时，它都会阻塞。当我们从单个流处理器（streamer）线程切换到若干个流式（streaming）任务时，这个问题变得非常明显。以下是你在Chrome69中看到的：<br><img src="devtools-69@2x.png" alt=""><br><font size=2>DevTools的问题是呈现整个解析器任务时示意它正在使用CPU（完全阻塞）</font></p><p>显示“Parse Script”任务需要1.08秒。然而，解析JavaScript并没有那么慢！大部分时间什么都没做，除了等待数据通过主线程。</p><p>Chrome 76描绘了一幅不同的画面：<br><img src="devtools-76@2x.png" alt=""><br><font size=2>在Chrome76中，解析被分解成多个更小的流式任务。</font></p><p>通常，DevTools性能面板对于全面了解页面上正在发生的事情非常有用。对于具体的V8特定指标，如JavaScript解析和编译时间，我们建议<a href="https://v8.dev/docs/rcs" target="_blank" rel="noopener">使用Chrome跟踪和运行时调用统计（RCS）</a>。在RCS结果中，Parse-Background和Compile-Background告诉你在主线程之外解析和编译JavaScript花费了多少时间，而Parse 和 Compile则捕获主线程指标。<br><img src="rcs@2x.png" alt=""></p><h4 id="这些变化对现实场景的影响是什么？"><a href="#这些变化对现实场景的影响是什么？" class="headerlink" title="这些变化对现实场景的影响是什么？"></a>这些变化对现实场景的影响是什么？</h4><p>让我们看一些真实网站的示例，以及如何处理脚本流。<br><img src="reddit-main-thread.svg" alt=""><br><font size=2>主线程vs Worker线程在MacBookPro上解析和编译Reddit的JS所花费的时间</font></p><p>Reddit.com网站有几个超过100kb的bundle，这些bundle被封装在外部函数中，导致主线程上的大量<a href="https://v8.dev/blog/preparser" target="_blank" rel="noopener">延迟编译</a>。如上图，真正的问题是主线程的耗时，因为主线程持续占用会延迟交互体验。Reddit将大部分时间花在主线程上，而Worker/Background线程的使用量很低。</p><p>他们可以将一些较大的bundle拆分成较小的bundle（例如每个50kb）且无需封装来获得收益，从而达到最大程度的并行，这样每个bundle都可以流式解析+单独编译，并减少启动期间的主线程解析/编译。<br><img src="facebook-main-thread.svg" alt=""><br><font size=2>主线程vs Worker线程在MacBookPro上解析和编译Facebook的JS所花费的时间</font></p><p>我们也可以看看Facebook.com。 Facebook约292个请求中加载了6MB左右的压缩JS，有些是异步的，有些是预加载的，有些是以较低优先级获取的。它们的许多脚本都非常小而且粒度很细，也因此可以同时进行流式解析/编译，从而有助于在Background/Worker线程上进行整体并行化。</p><p>注意，很可能你不是Facebook，并且没有类似Facebook或者Gmail这样历史悠久的适合大量脚本的桌面应用。但通常情况下，bundle需要保持粗粒度并且按需加载。</p><p>尽管大多数JavaScript解析和编译工作可以在Background线程上以流的方式进行，但仍有一些工作必须在主线程上进行。当主线程繁忙时，页面无法响应用户输入。请注意下载和执行代码对用户体验的影响。</p><blockquote><p>注意：目前，并不是所有JavaScript引擎和浏览器都将脚本流作为加载优化来实现。我们仍然相信，这里的总体指导会提升整体的用户体验。</p></blockquote><h4 id="解析JSON的开销"><a href="#解析JSON的开销" class="headerlink" title="解析JSON的开销"></a>解析JSON的开销</h4><p>因为JSON语法比JavaScript语法简单得多，所以JSON的解析比JavaScript更高效。基于这个前提，通过大型的类似JSON的配置对象字面量（例如内联Redux stores）可以提升web应用程序的启动性能，而不是通过数据内联为JavaScript对象字面量实现，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">42</span>, <span class="attr">bar</span>: <span class="number">1337</span> &#125;; <span class="comment">// 🐌</span></span><br></pre></td></tr></table></figure><p>…它可以用JSON字符串的形式表示，然后在运行时解析JSON：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"foo":42,"bar":1337&#125;'</span>); <span class="comment">// 🚀</span></span><br></pre></td></tr></table></figure><p>只要JSON字符串仅仅计算一次，那么JSON.parse方法要比JavaScript对象字面量<a href="https://github.com/GoogleChromeLabs/json-parse-benchmark" target="_blank" rel="noopener">快得多</a>，尤其是对于冷加载。将此技术应用于10kb或更大的对象是一条很好的经验法则，但与通常的性能建议一样，在进行任何更改之前先测量实际效果。<br><img src="json.svg" alt=""><br><font size=2>JSON.parse(‘…’)相比于等价的JavaScript字面量，在解析，编译和执行上要<a href="https://github.com/GoogleChromeLabs/json-parse-benchmark" target="_blank" rel="noopener">快得多</a>— 不仅仅是V8（快1.7倍），所有主要的JavaScript引擎都如此</font></p><p>下面的视频将从02:10开始详细介绍性能差异的来源。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/ff4fgQxPaO0?start=130" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><font size=2>“使用JSON.parse加速应用程序“Mathias Bynens在2019年#ChromeDevSummit上提出的。</font></p><p>请参阅<a href="https://v8.dev/features/subsume-json#embedding-json-parse" target="_blank" rel="noopener">我们的JSON⊂ECMAScript功能解释器</a>以获取一个示例实现，该实现在给定任意对象的情况下生成一个有效的JavaScript程序，然后通过JSON.parse处理它</p><p>对于大量数据使用普通对象字面量还有一个额外的风险：它们可能被解析两次！</p><ol><li>第一次发生在字面量准备就绪时。</li><li>第二次发生在字面量被延迟解析时。</li></ol><p>第一次不能避免。幸运的是，第二次通过将对象字面量放在顶层或<a href="https://v8.dev/blog/preparser#pife" target="_blank" rel="noopener">PIFE</a>内，可以避免。</p><h4 id="对于重复访问的解析-编译呢？"><a href="#对于重复访问的解析-编译呢？" class="headerlink" title="对于重复访问的解析/编译呢？"></a>对于重复访问的解析/编译呢？</h4><p>V8的（字节）代码缓存优化可以帮助您。当第一次请求一个脚本时，Chrome会下载它并将其提供给V8进行编译。它还将文件存储在浏览器的磁盘缓存中。当第二次请求JS文件时，Chrome从浏览器缓存中获取该文件，并再次将其交给V8进行编译。但是，这一次，编译的代码被序列化，并作为元数据附加到缓存的脚本文件中。<br><img src="code-caching@2x.png" alt=""><br><font size=2>代码缓存在V8中工作方式的可视化</font></p><p>第三次，Chrome从缓存中获取文件和文件的元数据，并将两者都交给V8。V8反序列化元数据，可以跳过编译。如果前两次访问发生在72小时内，则代码缓存将起作用。如果使用ServiceWorker缓存脚本，Chrome同样也具有代码缓存功能。你可以在<a href="https://v8.dev/blog/code-caching-for-devs" target="_blank" rel="noopener">面向web开发人员的代码缓存</a>中阅读更多有关代码缓存的信息。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在2019年，下载和执行时间是加载脚本的主要瓶颈。你可以为首屏内容设计一个小的同步（内联）脚本，页面其余部分使用若干defer脚本。分解大bundle，这样你就只关注在用户需要的时候发送他们需要的代码，可以最大化V8的并行处理。</p><p>在移动设备上，由于网络、内存消耗和较慢CPU的执行时间，你应该发送更少的脚本。在延迟和可缓存性之间进行平衡，以最大限度地增加主线程之外可能发生的解析和编译工作量。</p><h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><ul><li><a href="https://v8.dev/blog/scanner" target="_blank" rel="noopener">极快的解析，第1部分：优化扫描</a></li><li><a href="https://v8.dev/blog/preparser" target="_blank" rel="noopener">极快的解析，第2部分：惰性解析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;原文→&quot;&gt;&lt;a href=&quot;#原文→&quot; class=&quot;headerlink&quot; title=&quot;原文→&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://v8.dev/blog/cost-of-javascript-2019&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>理解Node.js事件循环阶段及其执行JavaScript代码的方式</title>
    <link href="https://100001.github.io/2020/07/23/Understanding-the-Node-js-event-loop-phases-and-how-it-executes-the-JavaScript-code/"/>
    <id>https://100001.github.io/2020/07/23/Understanding-the-Node-js-event-loop-phases-and-how-it-executes-the-JavaScript-code/</id>
    <published>2020-07-23T06:21:31.000Z</published>
    <updated>2020-07-30T05:56:52.639Z</updated>
    
    <content type="html"><![CDATA[<p><img src="5dlikj6szekblxlaseo4.png" alt=""></p><h4 id="原文→"><a href="#原文→" class="headerlink" title="原文→"></a><a href="https://dev.to/lunaticmonk/understanding-the-node-js-event-loop-phases-and-how-it-executes-the-javascript-code-1j9" target="_blank" rel="noopener">原文→</a></h4><p>我相信，如果您正在阅读本文，那么您一定已经听说了Node.js拥有著名的事件循环，它如何处理Node.js中的并发机制，以及它如何使Node.js成为事件驱动 I/O 的独特平台。 作为事件驱动的 I/O，执行的所有代码都是回调形式。 因此，重要的是要知道事件循环如何并且以何种顺序执行所有回调。 从这里开始，在此博客文章中，术语“事件循环”是指Node.js的事件循环。</p><p>从本质上讲，事件循环是一种在某些阶段进行迭代的机制。 您肯定听说过一个称为“事件循环迭代”的术语，该术语表示事件循环迭代贯穿其所有阶段。</p><p>在本文中，我将向您展示事件循环的底层架构及其所有阶段是什么，在哪个阶段中执行哪些代码，以及一些细节和最后一些示例，我认为它们将使您更好地理解关于事件循环的概念。</p><p>以下是事件循环按照其顺序迭代的所有阶段的图表：<br><img src="or3evh6lkjcg4zu1l300.png" alt=""><br>因此，事件循环是Node.js中的一种机制，它在一系列循环中进行迭代。 以下是事件循环迭代的各个阶段：</p><p>每个阶段都有一个 队列/堆，事件循环使用该 队列/堆 来 推送/存储 要执行的回调（Node.js中存在一个误解，即只有一个全局队列，在该队列中，回调被排队执行，这是不正确的）。</p><ol><li>Timers（计时器）：<br>JavaScript中的Timers回调（setTimeout，setInterval）保留在堆内存中，直到过期为止。 如果堆中有任何过期的Timers，则事件循环将使用与它们关联的回调，并以其延迟的升序开始执行它们，直到Timers队列为空。 但是，Timers回调的执行由事件循环的 Poll（轮询） 阶段控制（我们将在本文后面看到）。</li><li>Pending callbacks（待处理回调）：<br>在此阶段，事件循环执行与系统相关的回调（如果有）。 例如，假设您正在编写一个 Node 服务，而其他进程正在使用您要运行该进程的端口，则 Node 将抛出 ECONNREFUSED 错误，某些* nix系统可能由于操作系统正在处理其他一些任务而让回调等待执行。 因此，此类回调将被推送到待处理回调队列中以执行。</li><li>Idle/Prepare（空闲/准备）：<br>在此阶段，事件循环不执行任何操作。 它空闲，准备进入下一阶段。</li><li>Poll（轮询）：<br>这一阶段使Node.js变得独一无二。 在此阶段，事件循环会关注新的异步 I/O 回调。 除setTimeout，setInterval，setImmediate和close回调外，几乎所有回调都将执行。<br>基本上，事件循环在此阶段执行两件事：<ul><li>如果轮询阶段队列中已经有排队的回调，将执行它们，直到所有回调从轮询阶段回调队列中耗尽为止。</li><li>如果队列中没有回调，则事件循环将在轮询阶段停留一段时间。 现在，这个“一段时间”还取决于以下几点： <ul><li>如果setImmediate队列中存在要执行的回调，则事件循环在轮询阶段不会停留更长时间，而将进入下一个阶段，即Check / setImmediate。 再次，它将开始执行回调，直到Check / setImmediate阶段回调队列为空。</li><li>事件循环将从轮询阶段移出的第二种情况是，它知道有过期的Timers，这些Timers的回调正在等待执行。 在这种情况下，事件循环将移至下一阶段，即Check / setImmediate，然后移至Closing回调阶段，并最终从Timers阶段开始其下一次迭代。</li></ul></li></ul></li><li>Check / setImmediate：<br>在此阶段，事件循环从Check阶段的队列中获取回调，并开始一个接一个地执行直到队列为空。 当轮询阶段没有剩余要执行的回调并且轮询阶段变为空闲时，事件循环将进入此阶段。 通常，setImmediate的回调在此阶段执行。</li><li>Closing callbacks（关闭回调）：<br>在此阶段，事件循环执行与关闭事件关联的回调，例如 socket.on(‘close’，fn) 或 process.exit()。</li></ol><p>除了所有这些，还有一个微任务(microtask)队列，其中包含与process.nextTick相关的回调，我们将在稍后看到。</p><p>例子：<br>让我们从一个简单的示例开始，以了解如何执行以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>让我们回顾一下事件循环图，并结合其阶段说明，并尝试找出上述代码的输出：</p><p>当使用Node作为解释器执行时，以上代码的输出为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>事件循环进入Timers阶段并执行与上面的setTimeout相关的回调，然后进入随后的阶段（这些阶段并没有任何排队的回调），直到到达Check（setImmediate）阶段，在该阶段执行与它相关的回调函数。因此，输出期望的值。</p><p>注意：以上输出是可能被反转的，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>因为事件循环不能精确的在0毫秒时间内执行setTimeout(fn，0)的回调。而是在4-20毫秒的延迟后，执行回调。 （还记得吗？前面提到轮询阶段控制Timers回调的执行，因为它在轮询阶段等待一些I/O）。</p><p>现在，事件循环运行任何JavaScript代码时，都会发生两件事：</p><ol><li>当调用我们的JavaScript代码中的函数时，事件循环首先开始（而不是执行函数），然后将初始回调（即函数）注册到相应队列。</li><li>一旦它们注册，事件循环便进入其阶段，并开始迭代和执行回调，直到处理完所有回调为止。</li></ol><p>再举一个例子，或者说在Node.js中有一个误解，就是setTimeout(fn，0)总是在setImmediate之前执行，这是不对的！ 正如我们在上面的示例中看到的那样，事件循环最初处于Timers阶段，并且setTimeout定时器可能已过期，因此它先执行了，并且这种行为是不可预测的。 然而，并非总是如此，这完全取决于回调的数量，事件循环所处的阶段等等。</p><p>不管怎样，如果您执行以下操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'./xyz.txt'</span>, () =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">0</span>);</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>上面的代码将始终输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>让我们看看上面的代码是如何执行的：</p><ol><li>当我们调用main()函数时，事件循环首先执行而不是去执行回调。 我们遇到fs.readFile函数和已经注册的回调，并且该回调被推送到I/O阶段队列。 由于所有回调已注册了给定的函数，所以事件循环现在可以自由地开始执行回调。 因此，它从Timers开始遍历其各个阶段。 它在Timers和Pending回调阶段找不到任何内容。</li><li>当事件循环不断遍历其各个阶段并且看到文件读取操作已完成时，它将开始执行回调。</li></ol><p>请记住，事件循环开始执行fs.readFile的回调时，它处于I/O阶段，此后，它将移至Check（setImmediate）阶段。</p><ol><li>因此，Check阶段在当前运行的Timers阶段之前。 从而，在I/O阶段，setImmediate的回调将始终在setTimeout（fn，0）之前运行。</li></ol><p>（译者注：以上”请记住“后的内容比较难理解，我们可以把fs.readFile的回调执行那一刻，看做是在事件循环A的I/O阶段，执行完回调后，就先后注册了Timers（setTimeout）阶段 和 Check（setImmediate） 阶段的回调，然后事件循环A进入到Check阶段，这时因为刚刚注册过的setImmediate回调存在，所以先执行了setImmediate回调，然后再进入事件循环B的Timers阶段，去执行setTimeout。）</p><p>让我们再考虑一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">50</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'3'</span>));</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'4'</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>在我们了解事件循环如何执行此代码之前，需要了解一件事：</p><blockquote><p>process.nextTick属于微任务（microtasks），该微任务的优先级高于所有其他阶段，因此与之关联的回调在事件循环完成当前操作后立即执行。 这意味着，无论我们传递给process.nextTick的回调如何，事件循环都将完成其当前操作，然后从微任务队列执行回调，直到执行完。 队列执行完后，它将返回到其离开事件循环之前所处位置的阶段。</p></blockquote><ol><li>它首先检查微任务队列并在其中执行回调（在以上代码中为process.nextTick的回调）。</li><li>然后，它进入其第一阶段（Timers 阶段），其中50ms的计时器尚未到期。 因此，它前进到其他阶段。</li><li>然后，它进入 Check（setImmediate）阶段，在该阶段中看到计时器到期，并执行记录“ 3”的回调。</li><li>在事件循环的下一个迭代中，它看到50ms的计时器到期，因此记录为“ 1”。</li></ol><p>这是上面代码的输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>再看一个例子，这次我们将异步回调传递给我们的某一个process.nextTick。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">50</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'3'</span>));</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>上面的代码片段的输出是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>现在，执行上述代码时将发生以下情况：</p><ol><li>所有回调均已注册并推送到其各自的队列中。</li><li>如前面的示例所示，由于微任务队列回调是首先执行的，因此将首先输出“ 2”。 同样，此时，第二个process.nextTick回调即setTimeout(将记录为“ 4”）已开始执行，并最终被推送到Timers阶段队列。</li><li>现在，事件循环进入其正常阶段并执行回调。 它进入的第一阶段是“Timers”。 可以看到50ms的计时器没有到期，因此可以进一步进入下一个阶段。</li><li>然后，它进入“Check（setImmediate）”阶段并执行setImmediate的回调，该回调最终输出“ 3”。</li><li>现在，事件循环的下一个迭代开始。 在事件循环中，事件循环返回到“计时器”阶段，它会同时遇到过期的计时器（即注册时分别为50ms和1000ms），并执行与之关联的回调，该回调首先输出“ 1”，然后再输出“ 4”。</li></ol><p>因此，如您所见，事件循环的各种状态，其阶段以及最重要的是process.nextTick及其功能。 它基本上将提供给它的回调放在微任务队列中，并优先执行。</p><p>最后一个例子和一个详细的例子，您还记得这篇博文开头的事件循环图吗？ 好吧，看看下面的代码。 我希望您弄清楚以下代码的输出是什么。 在代码之后，我对事件循环如何执行以下代码进行了直观介绍。 它将帮助您更好地理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   <span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span>   <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="number">4</span>    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">0</span>);</span><br><span class="line"> <span class="number">5</span>    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span>    fs.readFile(<span class="string">'./xyz.txt'</span>, (err, buff) =&gt; &#123;</span><br><span class="line"> <span class="number">8</span>     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="number">9</span>      <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line"><span class="number">10</span>     &#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span>     process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="number">13</span>      <span class="built_in">console</span>.log(<span class="string">'process.nextTick'</span>);</span><br><span class="line"><span class="number">14</span>     &#125;);</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span>     setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'4'</span>));</span><br><span class="line"><span class="number">17</span>    &#125;);</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span>    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'5'</span>));</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="number">22</span>     process.on(<span class="string">'exit'</span>, (code) =&gt; &#123;</span><br><span class="line"><span class="number">23</span>      <span class="built_in">console</span>.log(<span class="string">`close callback`</span>);</span><br><span class="line"><span class="number">24</span>     &#125;);</span><br><span class="line"><span class="number">25</span>    &#125;, <span class="number">1100</span>);</span><br><span class="line"><span class="number">26</span>   &#125;</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span>   main();</span><br></pre></td></tr></table></figure><p>以下gif指示事件循环如何执行上述代码：</p><p>注意：</p><ol><li>以下gif中指示的队列中的数字是以上代码中的回调的行号。</li><li>由于我的重点是事件循环阶段如何执行代码，因此我没有在gif中插入Idle / Prepare阶段，因为它仅由事件循环在内部使用。<br><img src="xqave9c6288hgekmmvq5.gif" alt=""><br>以上代码将输出：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">process.nextTick</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">close callback</span><br></pre></td></tr></table></figure>或者，也可以是（回忆第一个例子）：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">process.nextTick</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">close callback</span><br></pre></td></tr></table></figure></li></ol><h4 id="其余"><a href="#其余" class="headerlink" title="其余:"></a>其余:</h4><h5 id="微任务-Microtasks"><a href="#微任务-Microtasks" class="headerlink" title="微任务(Microtasks):"></a>微任务(Microtasks):</h5><p>因此，Node.js中有一个东西或者说是在v8中准确的叫做“微任务（Microtasks）”。明确地说，微任务不是事件循环的一部分，而是v8的一部分。在本文前面，您可能已经阅读了有关process.nextTick的信息。 JavaScript中有一些任务属于微任务，分别是process.nextTick，Promise.resolve等。</p><p>这些任务的优先级高于其他任务/阶段，这意味着事件循环在结束其当前操作之后，将执行微任务队列的所有回调，直到执行完毕，然后恢复到其离开的阶段继续循环。</p><p>因此，每当Node.js遇到上面定义的任何微任务时，它都会将关联的回调推送到微任务队列并立即开始执行（对微任务进行优先级排序）并执行所有回调，直到队列完全执行完毕。</p><p>话虽这么说，如果您在微任务队列中放置了很多回调，您可能最终会饿死事件循环，因为它永远不会进入任何其他阶段。</p><h5 id="宏任务-Macrotasks"><a href="#宏任务-Macrotasks" class="headerlink" title="宏任务(Macrotasks):"></a>宏任务(Macrotasks):</h5><p>诸如setTimeout，setInterval，setImmediate，requestAnimationFrame，I / O，UI渲染或其他I / O回调之类的任务都属于宏任务（Macrotasks）。 他们没有事件循环优先级之类的东西。 回调是根据事件循环阶段执行的。</p><h4 id="事件循环Tick"><a href="#事件循环Tick" class="headerlink" title="事件循环Tick:"></a>事件循环Tick:</h4><p>我们说事件循环在其所有阶段迭代一次（事件循环的一次迭代）即是一次tick。<br>事件循环tick频率高和tick持续时间短（一次迭代所花费的时间）表示健康的事件循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;5dlikj6szekblxlaseo4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;原文→&quot;&gt;&lt;a href=&quot;#原文→&quot; class=&quot;headerlink&quot; title=&quot;原文→&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://dev.to/lu
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
