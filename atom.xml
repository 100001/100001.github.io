<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>100001</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://100001.github.io/"/>
  <updated>2020-08-03T07:02:07.600Z</updated>
  <id>https://100001.github.io/</id>
  
  <author>
    <name>Zhongwen Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>极速解析（一）: 优化扫描器</title>
    <link href="https://100001.github.io/2020/08/03/Blazingly-fast-parsing-part-1-optimizing-the-scanner/"/>
    <id>https://100001.github.io/2020/08/03/Blazingly-fast-parsing-part-1-optimizing-the-scanner/</id>
    <published>2020-08-02T16:28:09.000Z</published>
    <updated>2020-08-03T07:02:07.600Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原文→"><a href="#原文→" class="headerlink" title="原文→"></a><a href="https://v8.dev/blog/scanner" target="_blank" rel="noopener">原文→</a></h4><p>要运行JavaScript程序，需要处理源代码文本，以便V8能够理解它。V8首先将源代码解析为一棵抽象语法树（AST），这是一组表示程序结构的对象。然后AST被<a href="https://v8.dev/blog/ignition-interpreter" target="_blank" rel="noopener">Ignition</a>编译成字节码。这些解析+编译阶段的性能非常重要：V8在编译完成之前不能运行代码。在这一系列的博客文章中，我们将重点放在解析上，以及V8实现的快速解析器所完成的工作。</p><p>实际上，我们在解析器之前的一个阶段就开始了这个系列。V8的解析器读取的“tokens”是由“扫描器”提供的。Token是由若干具有单一语义含义的字符组成的块：字符串、标识符、运算符（例如：<code>++</code>）。扫描器通过组合底层字符流中的连续字符来构造这些tokens。</p><p>扫描器读取的是一串Unicode字符流。这些Unicode字符总是从UTF-16<a href="https://stackoverflow.com/questions/27331819/whats-the-difference-between-a-character-a-code-point-a-glyph-and-a-grapheme" target="_blank" rel="noopener">代码单元</a>流中解码。我们之所以只支持UTF-16编码规范，是为了避免对各种编码规范进行区分或定制化的扫描解析，同时这也是JavaScript字符串的编码规范，且源代码定位依赖于该编码规范。<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.h?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=46" target="_blank" rel="noopener"><code>UTF16CharacterStream</code></a>提供一种（可能被缓冲）UTF-16编码的方式来兼容底层Latin1、UTF-8或UTF-16编码，这些编码通过Chrome从网络上获取再传递给V8。除了支持多种编码规范外，扫描器和字符流的分离允许V8透明地扫描，就好像整个数据源是可用的一样，即使到目前为止我们可能只通过网络接收到部分数据。<br><img src="overview.svg" alt=""></p><p>在扫描器和字符流之间的接口是一个命名为<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.h?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=54" target="_blank" rel="noopener"><code>Utf16CharacterStream::Advance()</code></a>的方法，它返回下一个UTF-16代码单元，或者返回-1表示输入结束。一个UTF-16代码单元不能对每个Unicode字符进行编码。<a href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane" target="_blank" rel="noopener">基本多语言平面</a>之外的字符编码是两个代码单元，也称为代理对。不过，扫描器操作的是Unicode字符，而不是UTF-16代码单元，因此它将这个底层流接口封装在<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.h?sq=package:chromium&g=0&rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=569" target="_blank" rel="noopener"><code>Scanner::Advance()</code></a>方法中，该方法将UTF-16代码单元解码为完整的Unicode字符。当前解码的字符由<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.cc?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=775" target="_blank" rel="noopener"><code>Scanner::ScanString()</code></a>这样的扫描方法缓冲并取走。</p><p>扫描器根据最多4个字符（JavaScript中最长的模糊字符序列<a href="#fn1">[1]</a>）<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.cc?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=422" target="_blank" rel="noopener">选择</a>特定的扫描器方法或token。一旦选择了像<code>ScanString</code>这样的方法，它将处理该token的剩余字符，并为下一个扫描的token（非当前token的一部分）缓冲第一个字符。<code>ScanString</code>还将扫描的字符复制到编码为Latin1或UTF-16的缓冲区中，同时解码转义序列。</p><h4 id="空白符（Whitespace）"><a href="#空白符（Whitespace）" class="headerlink" title="空白符（Whitespace）"></a>空白符（Whitespace）</h4><p>Token可以用不同类型的空白符隔开，例如换行符、空格键、制表符、单行注释、多行注释等。一种类型的空白符后可以跟其他类型的空白符。如果添加空白符导致两个token之间出现换行，则可能<a href="https://tc39.es/ecma262/#sec-automatic-semicolon-insertion" target="_blank" rel="noopener">自动插入分号</a>。因此，在扫描下一个token之前，将略过所有空白符，并记录新的换行。大多数实际的JavaScript代码是被精简的，所以多个空白符并不常见。因此，V8统一独立地扫描每种类型的空白符，就好像它们是普通的token一样。例如，假设token的第一个字符是<code>/</code>，然后紧挨着另一个<code>/</code>，V8会将其扫描为单行注释，并返回<code>Token::WHITESPACE</code>。循环持续扫描，<a href="https://cs.chromium.org/chromium/src/v8/src/scanner.cc?rcl=edf3dab4660ed6273e5d46bd2b0eae9f3210157d&l=671" target="_blank" rel="noopener">直到</a>找出非<code>Token::WHITESPACE</code>的token。这意味着，如果下一个token之前没有空白符，我们将立即开始扫描相关的token，而不需要显式地检查空白符。</p><p>然而，循环本身会增加每次扫描token的开销：它需要一个分支来验证刚扫描的结果。如果我们刚刚扫描的token是<code>Token::WHITESPACE</code>，则最好继续循环。反之我们就应该跳出循环。实现这些，我们是通过将循环本身放到一个的单独的<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/scanner-inl.h?rcl=d62ec0d84f2ec8bc0d56ed7b8ed28eaee53ca94e&l=178" target="_blank" rel="noopener">辅助方法</a>中，该方法在确定不是<code>Token::WHITESPACE</code>token后，就直接返回token。尽管这类修改看起来很小，但它们消除了每次扫描token的开销。对于像标点符号这样的短token来说，尤其有效：<br><img src="punctuation.svg" alt=""></p><h4 id="标识符扫描"><a href="#标识符扫描" class="headerlink" title="标识符扫描"></a>标识符扫描</h4><p><a href="https://tc39.es/ecma262/#prod-Identifier" target="_blank" rel="noopener">标识符</a>是最复杂也是最常见的token，它用于JavaScript中的变量名（以及其它作用）。标识符以一个Unicode字符开头，并具有<a href="https://cs.chromium.org/chromium/src/v8/src/unicode.cc?rcl=d4096d05abfc992a150de884c25361917e06c6a9&l=807" target="_blank" rel="noopener"><code>ID_Start</code></a>属性，之后的字符序列是可选地，并具有<a href="https://cs.chromium.org/chromium/src/v8/src/unicode.cc?rcl=d4096d05abfc992a150de884c25361917e06c6a9&l=947" target="_blank" rel="noopener"><code>ID_Continue</code></a>属性。查看一个Unicode字符是否具有<code>ID_Start</code>或<code>ID_Continue</code>属性是非常消耗性能的。通过插入一个从字符到其属性的映射缓存，我们可以稍微加快速度。</p><p>虽然大多数JavaScript源代码是使用ASCII字符编写的。但在ASCII字符范围中，只有<code>a-z</code>，<code>A-Z</code>，<code>$</code>和<code>_</code>是标识符的起始字符。<code>ID_Continue</code>额外的包括<code>0-9</code>。我们通过创建一个表为128个ASCII字符中的每一个添加标记，识别是<code>ID_Start</code>字符，还是<code>ID_Continue</code>字符等，从而加速标识符扫描。当我们要查看的字符在ASCII范围内时，我们在这个表中查找对应的标记，并用一个单独的分支验证属性。直到我们找到第一个没有<code>ID_Continue</code>属性的字符之前，字符都是标识符的一部分。</p><p>本文中提到的所有改进加起来，在标识符扫描性能方面存在以下差异：<br><img src="identifiers-1.svg" alt=""></p><p>较长的标识符扫描速度更快，这点似乎有违直觉。这可能会使你认为增加标识符长度有利于提升性能。在MB/s这个维度上，扫描较长的标识符肯定更快，因为我们在一个非常紧密的循环中停留的时间更长，而没有返回解析器。但是，从应用程序性能的角度来看，你关注的是扫描全部token的速度。下图大致展示了每秒扫描的token数与token长度的关系：<br><img src="identifiers-2.svg" alt=""></p><p>这里很明显，使用较短的标识符对应用程序的解析性能是有益的：每秒我们能够扫描更多的token。这意味着，以MB/s作为衡量维度的站点看起来解析更快但信息密度较低，即实际上每秒生成的token更少。</p><h4 id="内化精简标识符（Internalizing-minified-identifiers）"><a href="#内化精简标识符（Internalizing-minified-identifiers）" class="headerlink" title="内化精简标识符（Internalizing minified identifiers）"></a>内化精简标识符（Internalizing minified identifiers）</h4><p>在扫描程序和解析器的边界上，所有字符串字面量和标识符都将删除重复数据。如果解析器请求字符串或标识符的值，对于每个可能的文本值，解析器将收到一个唯一的字符串对象。这通常需要一个哈希表来查找。由于JavaScript代码经常被精简，因此V8对单一的ASCII字符串使用简单的查询表。</p><h4 id="关键字（Identifier-scanning）"><a href="#关键字（Identifier-scanning）" class="headerlink" title="关键字（Identifier scanning）"></a>关键字（Identifier scanning）</h4><p>关键字是由编程语言定义的标识符的特殊子集，例如<code>if</code>、<code>else</code>和<code>function</code>。V8的扫描器返回的关键字token与标识符不同。扫描标识符后，我们需要识别该标识符是否是关键字。由于JavaScript中的所有关键字只包含小写字符a-z，所以我们还保留了一些标记，用来表明ASCII字符是否可能是关键字start和continue字符。</p><p>如果一个标识符根据标记可能是关键字，我们可以通过匹配标识符的第一个字符来找到候选关键字的子集。第一个字符比关键字的长度更独特，因此减少了后续条件分支的数量。对于每个字符，我们基于可能的关键字长度进行条件判断，并且只在长度相等的情况下再将标识符与关键字进行比较。</p><p>更好的方法是使用一种名为<a href="https://en.wikipedia.org/wiki/Perfect_hash_function" target="_blank" rel="noopener">完美哈希</a>的技术。由于关键字列表是静态的，我们可以计算出一个完美的哈希函数，对于每个标识符该函数最多只能给我们一个候选关键字。V8使用<a href="https://www.gnu.org/software/gperf/" target="_blank" rel="noopener">gperf</a>来计算这个函数。<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/keywords-gen.h" target="_blank" rel="noopener">结果</a>是根据标识符的长度和前两个字符计算出哈希，用来找到唯一候选关键字。只有当关键字的长度与输入标识符的长度匹配时，我们才比较标识符和关键字。这尤其加快了识别出标识符不是关键字的情况，因为我们只需要较少的条件分支来判断它。<br><img src="keywords.svg" alt=""></p><h4 id="代理对（Surrogate-pairs）"><a href="#代理对（Surrogate-pairs）" class="headerlink" title="代理对（Surrogate pairs）"></a><a href="https://baike.baidu.com/item/surrogate%20pair" target="_blank" rel="noopener">代理对（Surrogate pairs）</a></h4><p>如前所述，我们的扫描器工作在UTF-16编码的字符流上，但处理的是Unicode字符。<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84" target="_blank" rel="noopener">补充平面</a>中的字符只对标识符token有特殊意义。例如，假设这样的字符出现在字符串中，它们不会终止字符串。JS支持单个代理（Lone Surrogates），并且只从源代码复制。因此，除非绝对必要，最好避免组合代理对，并让扫描器直接对UTF-16代码单元进行操作而不是Unicode字符。当我们扫描一个字符串时，我们不需要寻找代理对，组合它们，然后在我们构建文本时再次拆分存储的字符。扫描器只剩下两个地方需要处理代理对。在token扫描开始时，只有当我们不能将识别某个字符时，才需要<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/scanner-inl.h?rcl=d4096d05abfc992a150de884c25361917e06c6a9&l=515" target="_blank" rel="noopener">组合</a>代理对用来检查结果是否是标识符开始。类似地，在处理非ASCII字符的标识符扫描的慢路径中，我们需要<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/scanner.cc?rcl=d4096d05abfc992a150de884c25361917e06c6a9&l=1003" target="_blank" rel="noopener">组合</a>代理对。</p><h4 id="AdvanceUntil"><a href="#AdvanceUntil" class="headerlink" title="AdvanceUntil"></a>AdvanceUntil</h4><p>扫描器和<code>UTF16CharacterStream</code>之间的接口边界是有状态的。流会记录它在缓冲区中的位置，在处理完每个代码单元之后，位置随之递增。在扫描器再次调用请求字符的扫描方法之前，会先缓冲一个已接收的代码单元。那个扫描方法读取缓冲的字符并且基于字符的值继续执行。这提供了很好的分层，但相当慢。去年秋天，我们的实习生Florian Sattler提出了一个改进的接口，它既保留了分层的优点，又能够在流中更快的访问代码单元。一个模板化的函数<a href="https://cs.chromium.org/chromium/src/v8/src/parsing/scanner.h?rcl=d4096d05abfc992a150de884c25361917e06c6a9&l=72" target="_blank" rel="noopener"><code>AdvanceUntil</code></a>，专门用于特定的扫描辅助函数，在流中每个字符都调用该辅助函数，直到辅助函数返回<code>false</code>。这本质上为扫描器提供了对底层数据的直接访问，而不会破坏抽象。它实际上简化了扫描辅助函数，因为它们不需要处理<code>EndOfInput</code>。<br><img src="advanceuntil.svg" alt=""></p><p><code>AdvanceUntil</code>对于加速可能需要消耗大量字符的扫描函数特别有用。我们用它来加速前面已经提到的标识符，以及字符串<a href="#fn2">[2]</a>和注释。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>扫描性能是解析器性能的基石。我们已经调整了扫描器，使之尽可能的高效。这导致了全面的改进，单token扫描的性能提高了大约1.4倍，字符串扫描提高了1.3倍，多行注释扫描提高了2.1倍，标识符扫描提高了1.2–1.5倍，这取决于标识符的长度。</p><p>我们的扫描器只能做这么多。作为开发人员，你可以通过增加程序的信息密度来进一步提高解析性能。最简单的方法是精简源代码，去掉不必要的空白符，并尽可能避免非ASCII标识符。理想情况下，这些步骤作为构建过程的一部分是自动化的，在这种情况下，编写代码时不必担心它。</p><hr><ol><li><code>&lt;!--</code>是HTML注释的开始，而<code>&lt;!-</code>扫描为“小于”、“非”、“减”。<a name="fn1">[↩︎]</a></li><li>不能用Latin1编码的字符串和标识符目前比较消耗性能，因为我们首先尝试将它们作为Latin1进行缓冲，一旦遇到不能用Latin1编码的字符，就将它们转换成UTF-16。<a name="fn2">[↩︎]</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;原文→&quot;&gt;&lt;a href=&quot;#原文→&quot; class=&quot;headerlink&quot; title=&quot;原文→&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://v8.dev/blog/scanner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文→&lt;/a&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2019 JavaScript的开销</title>
    <link href="https://100001.github.io/2020/07/29/The-Cost-of-JavaScript-in-2019/"/>
    <id>https://100001.github.io/2020/07/29/The-Cost-of-JavaScript-in-2019/</id>
    <published>2020-07-29T03:03:44.000Z</published>
    <updated>2020-07-30T05:57:58.909Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原文→"><a href="#原文→" class="headerlink" title="原文→"></a><a href="https://v8.dev/blog/cost-of-javascript-2019" target="_blank" rel="noopener">原文→</a></h4><blockquote><p>注意：如果你喜欢看演示文稿而不是阅读文章，那么请欣赏下面的视频！如果不是，跳过视频继续阅读。</p></blockquote><iframe width="560" height="315" src="https://www.youtube.com/embed/X9eRLElSW1c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><font size=2>“JavaScript的开销”由Addy Osmani在2019#PerfMatters大会上发表。</font></p><p>在过去几年里，JavaScript开销的一大变化是浏览器解析和编译脚本的速度有所提升。<strong>在2019年，处理脚本的主要开销是下载和CPU执行时间。</strong></p><p>如果浏览器的主线程忙于执行JavaScript，那么用户交互可能会延迟，因此优化脚本执行时间和网络的瓶颈可能会很有效果。</p><h4 id="可行的高级方案"><a href="#可行的高级方案" class="headerlink" title="可行的高级方案"></a>可行的高级方案</h4><p>这对web开发人员意味着什么？解析和编译开销不再像我们曾经认为的那样慢。JavaScript打包（bundle）需要关注的三件事是：</p><blockquote><p>译者注：对于bundle这个单词，在不同的上下文中，目前没有找到一个通用的中文词汇来翻译，因此直接用bundle也许更方便理解（类似的单词还包括chunk，worker等）</p></blockquote><ul><li><strong>减少下载时间</strong><ul><li>保持较小的JavaScript bundle，尤其是对于移动设备。体积小的bundle能够提高下载速度，降低内存使用率，并减少CPU消耗。</li><li>避免只有一个大的bundle；如果一个bundle超过50–100 kB，请将其拆分为独立且较小的bundle。（使用HTTP/2的多路复用，可以同时传递多个请求和响应消息，从而减少额外请求的开销。）</li><li>在移动设备上，由于网络速度的原因，你不希望过多的传输，而且还要保持低内存使用率。</li></ul></li><li><strong>改进执行时间</strong><ul><li>避免<a href="https://w3c.github.io/longtasks/" target="_blank" rel="noopener">耗时的任务</a>，因为这些任务会使主线程持续繁忙，并且会阻碍页面交互的速度。下载后，脚本执行时间现在是主要的开销。</li></ul></li><li><strong>避免使用大体积的内联脚本</strong>（因为它们仍然在主线程上被解析和编译）。一个好的经验法则是：如果脚本超过1KB，请避免内联它（这也是因为外部脚本的代码缓存起始于1KB）。</li></ul><h4 id="为什么下载和执行时间很重要？"><a href="#为什么下载和执行时间很重要？" class="headerlink" title="为什么下载和执行时间很重要？"></a>为什么下载和执行时间很重要？</h4><p>为什么优化下载和执行时间很重要？对于低速网络，下载时间至关重要。尽管4G（甚至5G）在世界各地都在增长，但我们的<a href="https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType" target="_blank" rel="noopener">有效连接类型</a>仍然不一致，因为我们中的许多人在旅途中遇到了感觉像3G（或更糟）的速度。</p><p>JavaScript的执行时间对于CPU速度慢的手机很重要。由于CPU、GPU和温控调频的不同，高端和低端手机的性能存在巨大差异。这对JavaScript的性能很重要，因为执行是受CPU限制的。</p><p>事实上，在Chrome这样的浏览器中，页面加载所花费的总时间中，有多达30%的时间用于JavaScript的执行。下图是在高端台式机上加载一个具有典型工作负载网站的页面（Reddit.com）：<br><img src="reddit-js-processing.svg" alt=""><br><font size=2>在V8中，JavaScript的执行过程占页面加载阶段所用时间的10-30%。</font></p><p>在移动设备上，与高端设备（Pixel 3）相比，中端手机（Moto G4）执行Reddit JavaScript的时间要长3-4倍，而在低端设备（低于100美元的Alcatel 1X）上，执行时间超过6倍：<br><img src="reddit-js-processing-devices.svg" alt=""><br><font size=2>Reddit的JavaScript在不同分类的设备（低端、普通和高端）上的耗时开销</font></p><blockquote><p>注意：Reddit在桌面端和移动端网页上有不同的体验，因此MacBook Pro的结果无法与其他结果进行比较。</p></blockquote><p>当你试图优化JavaScript的执行时间时，请注意可能会长期独占UI线程的<a href="https://web.dev/long-tasks-devtools/" target="_blank" rel="noopener">长任务</a>。即使页面看起来已经准备好了，也可以阻止关键任务的执行。把这些分解成更小的任务。通过拆分代码并确定加载顺序的优先级，你可以更快地让页面交互，并有望降低输入延迟。<br><img src="long-tasks@2x.png" alt=""><br><font size=2>长任务占据了主线程。你应该把它们分开。</font></p><h4 id="V8在改进解析-编译方面做了什么？"><a href="#V8在改进解析-编译方面做了什么？" class="headerlink" title="V8在改进解析/编译方面做了什么？"></a>V8在改进解析/编译方面做了什么？</h4><p>V8中的原始JavaScript解析速度比chrome60提高了2倍。同时，由于Chrome中的其他并行优化工作，原始解析（和编译）开销变得不那么明显/重要。</p><p>通过在Worker线程上解析和编译，V8平均减少了40%的主线程解析和编译工作量（例如，Facebook减少了46%，Pinterest减少了62%），最大的改进达到81%（YouTube）。这是对现有非主线程流式解析/编译的补充。<br><img src="chrome-js-parse-times.svg" alt=""><br><font size=2>不同版本的V8解析时间</font></p><p>我们还可以在Chrome发布的不同V8版本中可视化这些变化对CPU时间的影响。在Chrome61解析Facebook JS的同等时间内，现在Chrome75可以同时解析Facebook的JS和6倍Twitter的JS。<br><img src="js-parse-times-websites.svg" alt=""><br><font size=2>在Chrome61解析Facebook的JS时，Chrome75现在可以同时解析Facebook的JS和6倍Twitter的JS。</font></p><p>让我们深入了解这些变化是如何解锁的。简而言之，脚本资源可以在Worker线程上进行流式解析和编译，这意味着：</p><ul><li>V8可以解析+编译JavaScript而不阻塞主线程。</li><li>当完整的HTML解析器遇到&lt;script&gt;标签时，流解析就开始了。对于解析器阻塞脚本，HTML解析器暂停，而对于异步脚本则继续。</li><li>对于大多数实际的连接速度，V8的解析速度比下载快，因此V8在最后一个脚本字节下载后几毫秒内完成解析+编译。</li></ul><p>不那么简短的解释是…Chrome的老版本会在开始解析脚本之前下载完整的脚本，这是一种简单的方法，但它没有充分利用CPU。在41到68版本之间，一旦下载开始，Chrome就开始在一个单独的线程上解析async和defer脚本。<br><img src="script-streaming-1.svg" alt=""><br><font size=2>脚本以多个chunk的形式下载到浏览器。V8在接收到至少30kB时开始流式解析。</font></p><p>在Chrome71中，我们转向了基于任务的设置，在这种设置中，调度器可以同时解析多个async/defer脚本。这一变化的好处是主线程解析时间减少了约20%，根据实际网站的测量，TTI（Time To Interactive）/FID（First Input Delay）总体上提高了约2%。<br><img src="script-streaming-2.svg" alt=""><br><font size=2>Chrome71迁移到基于任务的设置中，调度器可以同时解析多个async/defer脚本。</font></p><p>在Chrome72中，我们切换到使用流作为主要的解析方式：现在也可以用这种方式解析常规的同步脚本（虽然不是内联脚本）。如果主线程需要的话，我们也停止了取消基于任务的解析，因为这会不必要地重复已经完成的任何工作。</p><p><a href="https://v8.dev/blog/v8-release-75#script-streaming-directly-from-network" target="_blank" rel="noopener">Chrome以前的版本</a>支持流式解析和编译，其中来自网络的脚本源数据必须先到达Chrome的主线程，然后才能转发到流处理器（streamer）。</p><p>这通常会导致流式解析器等待，因为主线程上的其他工作（如HTML解析、布局或JavaScript执行）阻塞了已经从网络下载的数据转发到流任务。</p><p>我们现在正尝试性的在预加载时开始解析，而main-thread-bounce（主线程回弹）在这之前会阻塞。</p><p>Leszek Swirski’s BlinkOn 演示呈现了更多细节:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/D1UJgiG4_NI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h4 id="这些变化如何反映你在DevTools中看到的内容？"><a href="#这些变化如何反映你在DevTools中看到的内容？" class="headerlink" title="这些变化如何反映你在DevTools中看到的内容？"></a>这些变化如何反映你在DevTools中看到的内容？</h4><p>除上述之外，DevTools中有个问题，它在呈现整个解析器任务时示意自己正在使用CPU（完全阻塞）。因此，每当解析器需要数据（需要遍历主线程）时，它都会阻塞。当我们从单个流处理器（streamer）线程切换到若干个流式（streaming）任务时，这个问题变得非常明显。以下是你在Chrome69中看到的：<br><img src="devtools-69@2x.png" alt=""><br><font size=2>DevTools的问题是呈现整个解析器任务时示意它正在使用CPU（完全阻塞）</font></p><p>显示“Parse Script”任务需要1.08秒。然而，解析JavaScript并没有那么慢！大部分时间什么都没做，除了等待数据通过主线程。</p><p>Chrome 76描绘了一幅不同的画面：<br><img src="devtools-76@2x.png" alt=""><br><font size=2>在Chrome76中，解析被分解成多个更小的流式任务。</font></p><p>通常，DevTools性能面板对于全面了解页面上正在发生的事情非常有用。对于具体的V8特定指标，如JavaScript解析和编译时间，我们建议<a href="https://v8.dev/docs/rcs" target="_blank" rel="noopener">使用Chrome跟踪和运行时调用统计（RCS）</a>。在RCS结果中，Parse-Background和Compile-Background告诉你在主线程之外解析和编译JavaScript花费了多少时间，而Parse 和 Compile则捕获主线程指标。<br><img src="rcs@2x.png" alt=""></p><h4 id="这些变化对现实场景的影响是什么？"><a href="#这些变化对现实场景的影响是什么？" class="headerlink" title="这些变化对现实场景的影响是什么？"></a>这些变化对现实场景的影响是什么？</h4><p>让我们看一些真实网站的示例，以及如何处理脚本流。<br><img src="reddit-main-thread.svg" alt=""><br><font size=2>主线程vs Worker线程在MacBookPro上解析和编译Reddit的JS所花费的时间</font></p><p>Reddit.com网站有几个超过100kb的bundle，这些bundle被封装在外部函数中，导致主线程上的大量<a href="https://v8.dev/blog/preparser" target="_blank" rel="noopener">延迟编译</a>。如上图，真正的问题是主线程的耗时，因为主线程持续占用会延迟交互体验。Reddit将大部分时间花在主线程上，而Worker/Background线程的使用量很低。</p><p>他们可以将一些较大的bundle拆分成较小的bundle（例如每个50kb）且无需封装来获得收益，从而达到最大程度的并行，这样每个bundle都可以流式解析+单独编译，并减少启动期间的主线程解析/编译。<br><img src="facebook-main-thread.svg" alt=""><br><font size=2>主线程vs Worker线程在MacBookPro上解析和编译Facebook的JS所花费的时间</font></p><p>我们也可以看看Facebook.com。 Facebook约292个请求中加载了6MB左右的压缩JS，有些是异步的，有些是预加载的，有些是以较低优先级获取的。它们的许多脚本都非常小而且粒度很细，也因此可以同时进行流式解析/编译，从而有助于在Background/Worker线程上进行整体并行化。</p><p>注意，很可能你不是Facebook，并且没有类似Facebook或者Gmail这样历史悠久的适合大量脚本的桌面应用。但通常情况下，bundle需要保持粗粒度并且按需加载。</p><p>尽管大多数JavaScript解析和编译工作可以在Background线程上以流的方式进行，但仍有一些工作必须在主线程上进行。当主线程繁忙时，页面无法响应用户输入。请注意下载和执行代码对用户体验的影响。</p><blockquote><p>注意：目前，并不是所有JavaScript引擎和浏览器都将脚本流作为加载优化来实现。我们仍然相信，这里的总体指导会提升整体的用户体验。</p></blockquote><h4 id="解析JSON的开销"><a href="#解析JSON的开销" class="headerlink" title="解析JSON的开销"></a>解析JSON的开销</h4><p>因为JSON语法比JavaScript语法简单得多，所以JSON的解析比JavaScript更高效。基于这个前提，通过大型的类似JSON的配置对象字面量（例如内联Redux stores）可以提升web应用程序的启动性能，而不是通过数据内联为JavaScript对象字面量实现，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">42</span>, <span class="attr">bar</span>: <span class="number">1337</span> &#125;; <span class="comment">// 🐌</span></span><br></pre></td></tr></table></figure><p>…它可以用JSON字符串的形式表示，然后在运行时解析JSON：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"foo":42,"bar":1337&#125;'</span>); <span class="comment">// 🚀</span></span><br></pre></td></tr></table></figure><p>只要JSON字符串仅仅计算一次，那么JSON.parse方法要比JavaScript对象字面量<a href="https://github.com/GoogleChromeLabs/json-parse-benchmark" target="_blank" rel="noopener">快得多</a>，尤其是对于冷加载。将此技术应用于10kb或更大的对象是一条很好的经验法则，但与通常的性能建议一样，在进行任何更改之前先测量实际效果。<br><img src="json.svg" alt=""><br><font size=2>JSON.parse(‘…’)相比于等价的JavaScript字面量，在解析，编译和执行上要<a href="https://github.com/GoogleChromeLabs/json-parse-benchmark" target="_blank" rel="noopener">快得多</a>— 不仅仅是V8（快1.7倍），所有主要的JavaScript引擎都如此</font></p><p>下面的视频将从02:10开始详细介绍性能差异的来源。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/ff4fgQxPaO0?start=130" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><font size=2>“使用JSON.parse加速应用程序“Mathias Bynens在2019年#ChromeDevSummit上提出的。</font></p><p>请参阅<a href="https://v8.dev/features/subsume-json#embedding-json-parse" target="_blank" rel="noopener">我们的JSON⊂ECMAScript功能解释器</a>以获取一个示例实现，该实现在给定任意对象的情况下生成一个有效的JavaScript程序，然后通过JSON.parse处理它</p><p>对于大量数据使用普通对象字面量还有一个额外的风险：它们可能被解析两次！</p><ol><li>第一次发生在字面量准备就绪时。</li><li>第二次发生在字面量被延迟解析时。</li></ol><p>第一次不能避免。幸运的是，第二次通过将对象字面量放在顶层或<a href="https://v8.dev/blog/preparser#pife" target="_blank" rel="noopener">PIFE</a>内，可以避免。</p><h4 id="对于重复访问的解析-编译呢？"><a href="#对于重复访问的解析-编译呢？" class="headerlink" title="对于重复访问的解析/编译呢？"></a>对于重复访问的解析/编译呢？</h4><p>V8的（字节）代码缓存优化可以帮助您。当第一次请求一个脚本时，Chrome会下载它并将其提供给V8进行编译。它还将文件存储在浏览器的磁盘缓存中。当第二次请求JS文件时，Chrome从浏览器缓存中获取该文件，并再次将其交给V8进行编译。但是，这一次，编译的代码被序列化，并作为元数据附加到缓存的脚本文件中。<br><img src="code-caching@2x.png" alt=""><br><font size=2>代码缓存在V8中工作方式的可视化</font></p><p>第三次，Chrome从缓存中获取文件和文件的元数据，并将两者都交给V8。V8反序列化元数据，可以跳过编译。如果前两次访问发生在72小时内，则代码缓存将起作用。如果使用ServiceWorker缓存脚本，Chrome同样也具有代码缓存功能。你可以在<a href="https://v8.dev/blog/code-caching-for-devs" target="_blank" rel="noopener">面向web开发人员的代码缓存</a>中阅读更多有关代码缓存的信息。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在2019年，下载和执行时间是加载脚本的主要瓶颈。你可以为首屏内容设计一个小的同步（内联）脚本，页面其余部分使用若干defer脚本。分解大bundle，这样你就只关注在用户需要的时候发送他们需要的代码，可以最大化V8的并行处理。</p><p>在移动设备上，由于网络、内存消耗和较慢CPU的执行时间，你应该发送更少的脚本。在延迟和可缓存性之间进行平衡，以最大限度地增加主线程之外可能发生的解析和编译工作量。</p><h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><ul><li><a href="https://v8.dev/blog/scanner" target="_blank" rel="noopener">极快的解析，第1部分：优化扫描</a></li><li><a href="https://v8.dev/blog/preparser" target="_blank" rel="noopener">极快的解析，第2部分：惰性解析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;原文→&quot;&gt;&lt;a href=&quot;#原文→&quot; class=&quot;headerlink&quot; title=&quot;原文→&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://v8.dev/blog/cost-of-javascript-2019&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>理解Node.js事件循环阶段及其执行JavaScript代码的方式</title>
    <link href="https://100001.github.io/2020/07/23/Understanding-the-Node-js-event-loop-phases-and-how-it-executes-the-JavaScript-code/"/>
    <id>https://100001.github.io/2020/07/23/Understanding-the-Node-js-event-loop-phases-and-how-it-executes-the-JavaScript-code/</id>
    <published>2020-07-23T06:21:31.000Z</published>
    <updated>2020-07-30T05:56:52.639Z</updated>
    
    <content type="html"><![CDATA[<p><img src="5dlikj6szekblxlaseo4.png" alt=""></p><h4 id="原文→"><a href="#原文→" class="headerlink" title="原文→"></a><a href="https://dev.to/lunaticmonk/understanding-the-node-js-event-loop-phases-and-how-it-executes-the-javascript-code-1j9" target="_blank" rel="noopener">原文→</a></h4><p>我相信，如果您正在阅读本文，那么您一定已经听说了Node.js拥有著名的事件循环，它如何处理Node.js中的并发机制，以及它如何使Node.js成为事件驱动 I/O 的独特平台。 作为事件驱动的 I/O，执行的所有代码都是回调形式。 因此，重要的是要知道事件循环如何并且以何种顺序执行所有回调。 从这里开始，在此博客文章中，术语“事件循环”是指Node.js的事件循环。</p><p>从本质上讲，事件循环是一种在某些阶段进行迭代的机制。 您肯定听说过一个称为“事件循环迭代”的术语，该术语表示事件循环迭代贯穿其所有阶段。</p><p>在本文中，我将向您展示事件循环的底层架构及其所有阶段是什么，在哪个阶段中执行哪些代码，以及一些细节和最后一些示例，我认为它们将使您更好地理解关于事件循环的概念。</p><p>以下是事件循环按照其顺序迭代的所有阶段的图表：<br><img src="or3evh6lkjcg4zu1l300.png" alt=""><br>因此，事件循环是Node.js中的一种机制，它在一系列循环中进行迭代。 以下是事件循环迭代的各个阶段：</p><p>每个阶段都有一个 队列/堆，事件循环使用该 队列/堆 来 推送/存储 要执行的回调（Node.js中存在一个误解，即只有一个全局队列，在该队列中，回调被排队执行，这是不正确的）。</p><ol><li>Timers（计时器）：<br>JavaScript中的Timers回调（setTimeout，setInterval）保留在堆内存中，直到过期为止。 如果堆中有任何过期的Timers，则事件循环将使用与它们关联的回调，并以其延迟的升序开始执行它们，直到Timers队列为空。 但是，Timers回调的执行由事件循环的 Poll（轮询） 阶段控制（我们将在本文后面看到）。</li><li>Pending callbacks（待处理回调）：<br>在此阶段，事件循环执行与系统相关的回调（如果有）。 例如，假设您正在编写一个 Node 服务，而其他进程正在使用您要运行该进程的端口，则 Node 将抛出 ECONNREFUSED 错误，某些* nix系统可能由于操作系统正在处理其他一些任务而让回调等待执行。 因此，此类回调将被推送到待处理回调队列中以执行。</li><li>Idle/Prepare（空闲/准备）：<br>在此阶段，事件循环不执行任何操作。 它空闲，准备进入下一阶段。</li><li>Poll（轮询）：<br>这一阶段使Node.js变得独一无二。 在此阶段，事件循环会关注新的异步 I/O 回调。 除setTimeout，setInterval，setImmediate和close回调外，几乎所有回调都将执行。<br>基本上，事件循环在此阶段执行两件事：<ul><li>如果轮询阶段队列中已经有排队的回调，将执行它们，直到所有回调从轮询阶段回调队列中耗尽为止。</li><li>如果队列中没有回调，则事件循环将在轮询阶段停留一段时间。 现在，这个“一段时间”还取决于以下几点： <ul><li>如果setImmediate队列中存在要执行的回调，则事件循环在轮询阶段不会停留更长时间，而将进入下一个阶段，即Check / setImmediate。 再次，它将开始执行回调，直到Check / setImmediate阶段回调队列为空。</li><li>事件循环将从轮询阶段移出的第二种情况是，它知道有过期的Timers，这些Timers的回调正在等待执行。 在这种情况下，事件循环将移至下一阶段，即Check / setImmediate，然后移至Closing回调阶段，并最终从Timers阶段开始其下一次迭代。</li></ul></li></ul></li><li>Check / setImmediate：<br>在此阶段，事件循环从Check阶段的队列中获取回调，并开始一个接一个地执行直到队列为空。 当轮询阶段没有剩余要执行的回调并且轮询阶段变为空闲时，事件循环将进入此阶段。 通常，setImmediate的回调在此阶段执行。</li><li>Closing callbacks（关闭回调）：<br>在此阶段，事件循环执行与关闭事件关联的回调，例如 socket.on(‘close’，fn) 或 process.exit()。</li></ol><p>除了所有这些，还有一个微任务(microtask)队列，其中包含与process.nextTick相关的回调，我们将在稍后看到。</p><p>例子：<br>让我们从一个简单的示例开始，以了解如何执行以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>让我们回顾一下事件循环图，并结合其阶段说明，并尝试找出上述代码的输出：</p><p>当使用Node作为解释器执行时，以上代码的输出为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>事件循环进入Timers阶段并执行与上面的setTimeout相关的回调，然后进入随后的阶段（这些阶段并没有任何排队的回调），直到到达Check（setImmediate）阶段，在该阶段执行与它相关的回调函数。因此，输出期望的值。</p><p>注意：以上输出是可能被反转的，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>因为事件循环不能精确的在0毫秒时间内执行setTimeout(fn，0)的回调。而是在4-20毫秒的延迟后，执行回调。 （还记得吗？前面提到轮询阶段控制Timers回调的执行，因为它在轮询阶段等待一些I/O）。</p><p>现在，事件循环运行任何JavaScript代码时，都会发生两件事：</p><ol><li>当调用我们的JavaScript代码中的函数时，事件循环首先开始（而不是执行函数），然后将初始回调（即函数）注册到相应队列。</li><li>一旦它们注册，事件循环便进入其阶段，并开始迭代和执行回调，直到处理完所有回调为止。</li></ol><p>再举一个例子，或者说在Node.js中有一个误解，就是setTimeout(fn，0)总是在setImmediate之前执行，这是不对的！ 正如我们在上面的示例中看到的那样，事件循环最初处于Timers阶段，并且setTimeout定时器可能已过期，因此它先执行了，并且这种行为是不可预测的。 然而，并非总是如此，这完全取决于回调的数量，事件循环所处的阶段等等。</p><p>不管怎样，如果您执行以下操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'./xyz.txt'</span>, () =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">0</span>);</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>上面的代码将始终输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>让我们看看上面的代码是如何执行的：</p><ol><li>当我们调用main()函数时，事件循环首先执行而不是去执行回调。 我们遇到fs.readFile函数和已经注册的回调，并且该回调被推送到I/O阶段队列。 由于所有回调已注册了给定的函数，所以事件循环现在可以自由地开始执行回调。 因此，它从Timers开始遍历其各个阶段。 它在Timers和Pending回调阶段找不到任何内容。</li><li>当事件循环不断遍历其各个阶段并且看到文件读取操作已完成时，它将开始执行回调。</li></ol><p>请记住，事件循环开始执行fs.readFile的回调时，它处于I/O阶段，此后，它将移至Check（setImmediate）阶段。</p><ol><li>因此，Check阶段在当前运行的Timers阶段之前。 从而，在I/O阶段，setImmediate的回调将始终在setTimeout（fn，0）之前运行。</li></ol><p>（译者注：以上”请记住“后的内容比较难理解，我们可以把fs.readFile的回调执行那一刻，看做是在事件循环A的I/O阶段，执行完回调后，就先后注册了Timers（setTimeout）阶段 和 Check（setImmediate） 阶段的回调，然后事件循环A进入到Check阶段，这时因为刚刚注册过的setImmediate回调存在，所以先执行了setImmediate回调，然后再进入事件循环B的Timers阶段，去执行setTimeout。）</p><p>让我们再考虑一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">50</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'3'</span>));</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'4'</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>在我们了解事件循环如何执行此代码之前，需要了解一件事：</p><blockquote><p>process.nextTick属于微任务（microtasks），该微任务的优先级高于所有其他阶段，因此与之关联的回调在事件循环完成当前操作后立即执行。 这意味着，无论我们传递给process.nextTick的回调如何，事件循环都将完成其当前操作，然后从微任务队列执行回调，直到执行完。 队列执行完后，它将返回到其离开事件循环之前所处位置的阶段。</p></blockquote><ol><li>它首先检查微任务队列并在其中执行回调（在以上代码中为process.nextTick的回调）。</li><li>然后，它进入其第一阶段（Timers 阶段），其中50ms的计时器尚未到期。 因此，它前进到其他阶段。</li><li>然后，它进入 Check（setImmediate）阶段，在该阶段中看到计时器到期，并执行记录“ 3”的回调。</li><li>在事件循环的下一个迭代中，它看到50ms的计时器到期，因此记录为“ 1”。</li></ol><p>这是上面代码的输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>再看一个例子，这次我们将异步回调传递给我们的某一个process.nextTick。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">50</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'3'</span>));</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>上面的代码片段的输出是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>现在，执行上述代码时将发生以下情况：</p><ol><li>所有回调均已注册并推送到其各自的队列中。</li><li>如前面的示例所示，由于微任务队列回调是首先执行的，因此将首先输出“ 2”。 同样，此时，第二个process.nextTick回调即setTimeout(将记录为“ 4”）已开始执行，并最终被推送到Timers阶段队列。</li><li>现在，事件循环进入其正常阶段并执行回调。 它进入的第一阶段是“Timers”。 可以看到50ms的计时器没有到期，因此可以进一步进入下一个阶段。</li><li>然后，它进入“Check（setImmediate）”阶段并执行setImmediate的回调，该回调最终输出“ 3”。</li><li>现在，事件循环的下一个迭代开始。 在事件循环中，事件循环返回到“计时器”阶段，它会同时遇到过期的计时器（即注册时分别为50ms和1000ms），并执行与之关联的回调，该回调首先输出“ 1”，然后再输出“ 4”。</li></ol><p>因此，如您所见，事件循环的各种状态，其阶段以及最重要的是process.nextTick及其功能。 它基本上将提供给它的回调放在微任务队列中，并优先执行。</p><p>最后一个例子和一个详细的例子，您还记得这篇博文开头的事件循环图吗？ 好吧，看看下面的代码。 我希望您弄清楚以下代码的输出是什么。 在代码之后，我对事件循环如何执行以下代码进行了直观介绍。 它将帮助您更好地理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   <span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span>   <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="number">4</span>    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">0</span>);</span><br><span class="line"> <span class="number">5</span>    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span>    fs.readFile(<span class="string">'./xyz.txt'</span>, (err, buff) =&gt; &#123;</span><br><span class="line"> <span class="number">8</span>     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="number">9</span>      <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line"><span class="number">10</span>     &#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span>     process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="number">13</span>      <span class="built_in">console</span>.log(<span class="string">'process.nextTick'</span>);</span><br><span class="line"><span class="number">14</span>     &#125;);</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span>     setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'4'</span>));</span><br><span class="line"><span class="number">17</span>    &#125;);</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span>    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'5'</span>));</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="number">22</span>     process.on(<span class="string">'exit'</span>, (code) =&gt; &#123;</span><br><span class="line"><span class="number">23</span>      <span class="built_in">console</span>.log(<span class="string">`close callback`</span>);</span><br><span class="line"><span class="number">24</span>     &#125;);</span><br><span class="line"><span class="number">25</span>    &#125;, <span class="number">1100</span>);</span><br><span class="line"><span class="number">26</span>   &#125;</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span>   main();</span><br></pre></td></tr></table></figure><p>以下gif指示事件循环如何执行上述代码：</p><p>注意：</p><ol><li>以下gif中指示的队列中的数字是以上代码中的回调的行号。</li><li>由于我的重点是事件循环阶段如何执行代码，因此我没有在gif中插入Idle / Prepare阶段，因为它仅由事件循环在内部使用。<br><img src="xqave9c6288hgekmmvq5.gif" alt=""><br>以上代码将输出：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">process.nextTick</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">close callback</span><br></pre></td></tr></table></figure>或者，也可以是（回忆第一个例子）：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">process.nextTick</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">close callback</span><br></pre></td></tr></table></figure></li></ol><h4 id="其余"><a href="#其余" class="headerlink" title="其余:"></a>其余:</h4><h5 id="微任务-Microtasks"><a href="#微任务-Microtasks" class="headerlink" title="微任务(Microtasks):"></a>微任务(Microtasks):</h5><p>因此，Node.js中有一个东西或者说是在v8中准确的叫做“微任务（Microtasks）”。明确地说，微任务不是事件循环的一部分，而是v8的一部分。在本文前面，您可能已经阅读了有关process.nextTick的信息。 JavaScript中有一些任务属于微任务，分别是process.nextTick，Promise.resolve等。</p><p>这些任务的优先级高于其他任务/阶段，这意味着事件循环在结束其当前操作之后，将执行微任务队列的所有回调，直到执行完毕，然后恢复到其离开的阶段继续循环。</p><p>因此，每当Node.js遇到上面定义的任何微任务时，它都会将关联的回调推送到微任务队列并立即开始执行（对微任务进行优先级排序）并执行所有回调，直到队列完全执行完毕。</p><p>话虽这么说，如果您在微任务队列中放置了很多回调，您可能最终会饿死事件循环，因为它永远不会进入任何其他阶段。</p><h5 id="宏任务-Macrotasks"><a href="#宏任务-Macrotasks" class="headerlink" title="宏任务(Macrotasks):"></a>宏任务(Macrotasks):</h5><p>诸如setTimeout，setInterval，setImmediate，requestAnimationFrame，I / O，UI渲染或其他I / O回调之类的任务都属于宏任务（Macrotasks）。 他们没有事件循环优先级之类的东西。 回调是根据事件循环阶段执行的。</p><h4 id="事件循环Tick"><a href="#事件循环Tick" class="headerlink" title="事件循环Tick:"></a>事件循环Tick:</h4><p>我们说事件循环在其所有阶段迭代一次（事件循环的一次迭代）即是一次tick。<br>事件循环tick频率高和tick持续时间短（一次迭代所花费的时间）表示健康的事件循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;5dlikj6szekblxlaseo4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;原文→&quot;&gt;&lt;a href=&quot;#原文→&quot; class=&quot;headerlink&quot; title=&quot;原文→&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://dev.to/lu
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
