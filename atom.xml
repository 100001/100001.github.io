<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>100001</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://100001.github.io/"/>
  <updated>2020-07-30T03:58:41.484Z</updated>
  <id>https://100001.github.io/</id>
  
  <author>
    <name>Zhongwen Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019年JavaScript的开销</title>
    <link href="https://100001.github.io/2020/07/29/The-Cost-of-JavaScript-in-2019/"/>
    <id>https://100001.github.io/2020/07/29/The-Cost-of-JavaScript-in-2019/</id>
    <published>2020-07-29T03:03:44.000Z</published>
    <updated>2020-07-30T03:58:41.484Z</updated>
    
    <content type="html"><![CDATA[<h4 id="原文→"><a href="#原文→" class="headerlink" title="原文→"></a><a href="https://v8.dev/blog/cost-of-javascript-2019" target="_blank" rel="noopener">原文→</a></h4><blockquote><p>注意：如果你喜欢看演示文稿而不是阅读文章，那么请欣赏下面的视频！如果不是，跳过视频继续阅读。</p></blockquote><iframe width="560" height="315" src="https://www.youtube.com/embed/X9eRLElSW1c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><font size=2>“JavaScript的开销”由Addy Osmani在2019#PerfMatters大会上发表。</font></p><p>在过去几年里，JavaScript开销的一大变化是浏览器解析和编译脚本的速度有所提升。<strong>在2019年，处理脚本的主要开销是下载和CPU执行时间。</strong></p><p>如果浏览器的主线程忙于执行JavaScript，那么用户交互可能会延迟，因此优化脚本执行时间和网络的瓶颈可能会很有效果。</p><h4 id="可行的高级方案"><a href="#可行的高级方案" class="headerlink" title="可行的高级方案"></a>可行的高级方案</h4><p>这对web开发人员意味着什么？解析和编译开销不再像我们曾经认为的那样慢。JavaScript打包（bundle）需要关注的三件事是：</p><blockquote><p>译者注：对于bundle这个单词，在不同的上下文中，目前没有找到一个通用的中文词汇来翻译，因此直接用bundle也许更方便理解（类似的单词还包括chunk，worker等）</p></blockquote><ul><li><strong>减少下载时间</strong><ul><li>保持较小的JavaScript bundle，尤其是对于移动设备。体积小的bundle能够提高下载速度，降低内存使用率，并减少CPU消耗。</li><li>避免只有一个大的bundle；如果一个bundle超过50–100 kB，请将其拆分为独立且较小的bundle。（使用HTTP/2的多路复用，可以同时传递多个请求和响应消息，从而减少额外请求的开销。）</li><li>在移动设备上，由于网络速度的原因，你不希望过多的传输，而且还要保持低内存使用率。</li></ul></li><li><strong>改进执行时间</strong><ul><li>避免<a href="https://w3c.github.io/longtasks/" target="_blank" rel="noopener">耗时的任务</a>，因为这些任务会使主线程持续繁忙，并且会阻碍页面交互的速度。下载后，脚本执行时间现在是主要的开销。</li></ul></li><li><strong>避免使用大体积的内联脚本</strong>（因为它们仍然在主线程上被解析和编译）。一个好的经验法则是：如果脚本超过1KB，请避免内联它（这也是因为外部脚本的代码缓存起始于1KB）。</li></ul><h4 id="为什么下载和执行时间很重要？"><a href="#为什么下载和执行时间很重要？" class="headerlink" title="为什么下载和执行时间很重要？"></a>为什么下载和执行时间很重要？</h4><p>为什么优化下载和执行时间很重要？对于低速网络，下载时间至关重要。尽管4G（甚至5G）在世界各地都在增长，但我们的<a href="https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/effectiveType" target="_blank" rel="noopener">有效连接类型</a>仍然不一致，因为我们中的许多人在旅途中遇到了感觉像3G（或更糟）的速度。</p><p>JavaScript的执行时间对于CPU速度慢的手机很重要。由于CPU、GPU和温控调频的不同，高端和低端手机的性能存在巨大差异。这对JavaScript的性能很重要，因为执行是受CPU限制的。</p><p>事实上，在Chrome这样的浏览器中，页面加载所花费的总时间中，有多达30%的时间用于JavaScript的执行。下图是在高端台式机上加载一个具有典型工作负载网站的页面（Reddit.com）：<br><img src="reddit-js-processing.svg" alt=""><br><font size=2>在V8中，JavaScript的执行过程占页面加载阶段所用时间的10-30%。</font></p><p>在移动设备上，与高端设备（Pixel 3）相比，中端手机（Moto G4）执行Reddit JavaScript的时间要长3-4倍，而在低端设备（低于100美元的Alcatel 1X）上，执行时间超过6倍：<br><img src="reddit-js-processing-devices.svg" alt=""><br><font size=2>Reddit的JavaScript在不同分类的设备（低端、普通和高端）上的耗时开销</font></p><blockquote><p>注意：Reddit在桌面端和移动端网页上有不同的体验，因此MacBook Pro的结果无法与其他结果进行比较。</p></blockquote><p>当你试图优化JavaScript的执行时间时，请注意可能会长期独占UI线程的<a href="https://web.dev/long-tasks-devtools/" target="_blank" rel="noopener">长任务</a>。即使页面看起来已经准备好了，也可以阻止关键任务的执行。把这些分解成更小的任务。通过拆分代码并确定加载顺序的优先级，你可以更快地让页面交互，并有望降低输入延迟。<br><img src="long-tasks@2x.png" alt=""><br><font size=2>长任务占据了主线程。你应该把它们分开。</font></p><h4 id="V8在改进解析-编译方面做了什么？"><a href="#V8在改进解析-编译方面做了什么？" class="headerlink" title="V8在改进解析/编译方面做了什么？"></a>V8在改进解析/编译方面做了什么？</h4><p>V8中的原始JavaScript解析速度比chrome60提高了2倍。同时，由于Chrome中的其他并行优化工作，原始解析（和编译）开销变得不那么明显/重要。</p><p>通过在Worker线程上解析和编译，V8平均减少了40%的主线程解析和编译工作量（例如，Facebook减少了46%，Pinterest减少了62%），最大的改进达到81%（YouTube）。这是对现有非主线程流式解析/编译的补充。<br><img src="chrome-js-parse-times.svg" alt=""><br><font size=2>不同版本的V8解析时间</font></p><p>我们还可以在Chrome发布的不同V8版本中可视化这些变化对CPU时间的影响。在Chrome61解析Facebook JS的同等时间内，现在Chrome75可以同时解析Facebook的JS和6倍Twitter的JS。<br><img src="js-parse-times-websites.svg" alt=""><br><font size=2>在Chrome61解析Facebook的JS时，Chrome75现在可以同时解析Facebook的JS和6倍Twitter的JS。</font></p><p>让我们深入了解这些变化是如何解锁的。简而言之，脚本资源可以在Worker线程上进行流式解析和编译，这意味着：</p><ul><li>V8可以解析+编译JavaScript而不阻塞主线程。</li><li>当完整的HTML解析器遇到&lt;script&gt;标签时，流解析就开始了。对于解析器阻塞脚本，HTML解析器暂停，而对于异步脚本则继续。</li><li>对于大多数实际的连接速度，V8的解析速度比下载快，因此V8在最后一个脚本字节下载后几毫秒内完成解析+编译。</li></ul><p>不那么简短的解释是…Chrome的老版本会在开始解析脚本之前下载完整的脚本，这是一种简单的方法，但它没有充分利用CPU。在41到68版本之间，一旦下载开始，Chrome就开始在一个单独的线程上解析async和defer脚本。<br><img src="script-streaming-1.svg" alt=""><br><font size=2>脚本以多个chunk的形式下载到浏览器。V8在接收到至少30kB时开始流式解析。</font></p><p>在Chrome71中，我们转向了基于任务的设置，在这种设置中，调度器可以同时解析多个async/defer脚本。这一变化的好处是主线程解析时间减少了约20%，根据实际网站的测量，TTI（Time To Interactive）/FID（First Input Delay）总体上提高了约2%。<br><img src="script-streaming-2.svg" alt=""><br><font size=2>Chrome71迁移到基于任务的设置中，调度器可以同时解析多个async/defer脚本。</font></p><p>在Chrome72中，我们切换到使用流作为主要的解析方式：现在也可以用这种方式解析常规的同步脚本（虽然不是内联脚本）。如果主线程需要的话，我们也停止了取消基于任务的解析，因为这会不必要地重复已经完成的任何工作。</p><p><a href="https://v8.dev/blog/v8-release-75#script-streaming-directly-from-network" target="_blank" rel="noopener">Chrome以前的版本</a>支持流式解析和编译，其中来自网络的脚本源数据必须先到达Chrome的主线程，然后才能转发到流处理器（streamer）。</p><p>这通常会导致流式解析器等待，因为主线程上的其他工作（如HTML解析、布局或JavaScript执行）阻塞了已经从网络下载的数据转发到流任务。</p><p>我们现在正尝试性的在预加载时开始解析，而main-thread-bounce（主线程回弹）在这之前会阻塞。</p><p>Leszek Swirski’s BlinkOn 演示呈现了更多细节:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/D1UJgiG4_NI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h4 id="这些变化如何反映你在DevTools中看到的内容？"><a href="#这些变化如何反映你在DevTools中看到的内容？" class="headerlink" title="这些变化如何反映你在DevTools中看到的内容？"></a>这些变化如何反映你在DevTools中看到的内容？</h4><p>除上述之外，DevTools中有个问题，它在呈现整个解析器任务时示意自己正在使用CPU（完全阻塞）。因此，每当解析器需要数据（需要遍历主线程）时，它都会阻塞。当我们从单个流处理器（streamer）线程切换到若干个流式（streaming）任务时，这个问题变得非常明显。以下是你在Chrome69中看到的：<br><img src="devtools-69@2x.png" alt=""><br><font size=2>DevTools的问题是呈现整个解析器任务时示意它正在使用CPU（完全阻塞）</font></p><p>显示“Parse Script”任务需要1.08秒。然而，解析JavaScript并没有那么慢！大部分时间什么都没做，除了等待数据通过主线程。</p><p>Chrome 76描绘了一幅不同的画面：<br><img src="devtools-76@2x.png" alt=""><br><font size=2>在Chrome76中，解析被分解成多个更小的流式任务。</font></p><p>通常，DevTools性能面板对于全面了解页面上正在发生的事情非常有用。对于具体的V8特定指标，如JavaScript解析和编译时间，我们建议<a href="https://v8.dev/docs/rcs" target="_blank" rel="noopener">使用Chrome跟踪和运行时调用统计（RCS）</a>。在RCS结果中，Parse-Background和Compile-Background告诉你在主线程之外解析和编译JavaScript花费了多少时间，而Parse 和 Compile则捕获主线程指标。<br><img src="rcs@2x.png" alt=""></p><h4 id="这些变化对现实场景的影响是什么？"><a href="#这些变化对现实场景的影响是什么？" class="headerlink" title="这些变化对现实场景的影响是什么？"></a>这些变化对现实场景的影响是什么？</h4><p>让我们看一些真实网站的示例，以及如何处理脚本流。<br><img src="reddit-main-thread.svg" alt=""><br><font size=2>主线程vs Worker线程在MacBookPro上解析和编译Reddit的JS所花费的时间</font></p><p>Reddit.com网站有几个超过100kb的bundle，这些bundle被封装在外部函数中，导致主线程上的大量<a href="https://v8.dev/blog/preparser" target="_blank" rel="noopener">延迟编译</a>。如上图，真正的问题是主线程的耗时，因为主线程持续占用会延迟交互体验。Reddit将大部分时间花在主线程上，而Worker/Background线程的使用量很低。</p><p>他们可以将一些较大的bundle拆分成较小的bundle（例如每个50kb）且无需封装来获得收益，从而达到最大程度的并行，这样每个bundle都可以流式解析+单独编译，并减少启动期间的主线程解析/编译。<br><img src="facebook-main-thread.svg" alt=""><br><font size=2>主线程vs Worker线程在MacBookPro上解析和编译Facebook的JS所花费的时间</font></p><p>我们也可以看看Facebook.com。 Facebook约292个请求中加载了6MB左右的压缩JS，有些是异步的，有些是预加载的，有些是以较低优先级获取的。它们的许多脚本都非常小而且粒度很细，也因此可以同时进行流式解析/编译，从而有助于在Background/Worker线程上进行整体并行化。</p><p>注意，很可能你不是Facebook，并且没有类似Facebook或者Gmail这样历史悠久的适合大量脚本的桌面应用。但通常情况下，bundle需要保持粗粒度并且按需加载。</p><p>尽管大多数JavaScript解析和编译工作可以在Background线程上以流的方式进行，但仍有一些工作必须在主线程上进行。当主线程繁忙时，页面无法响应用户输入。请注意下载和执行代码对用户体验的影响。</p><blockquote><p>注意：目前，并不是所有JavaScript引擎和浏览器都将脚本流作为加载优化来实现。我们仍然相信，这里的总体指导会提升整体的用户体验。</p></blockquote><h4 id="解析JSON的开销"><a href="#解析JSON的开销" class="headerlink" title="解析JSON的开销"></a>解析JSON的开销</h4><p>因为JSON语法比JavaScript语法简单得多，所以JSON的解析比JavaScript更高效。基于这个前提，通过大型的类似JSON的配置对象字面量（例如内联Redux stores）可以提升web应用程序的启动性能，而不是通过数据内联为JavaScript对象字面量实现，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">42</span>, <span class="attr">bar</span>: <span class="number">1337</span> &#125;; <span class="comment">// 🐌</span></span><br></pre></td></tr></table></figure><p>…它可以用JSON字符串的形式表示，然后在运行时解析JSON：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"foo":42,"bar":1337&#125;'</span>); <span class="comment">// 🚀</span></span><br></pre></td></tr></table></figure><p>只要JSON字符串仅仅计算一次，那么JSON.parse方法要比JavaScript对象字面量<a href="https://github.com/GoogleChromeLabs/json-parse-benchmark" target="_blank" rel="noopener">快得多</a>，尤其是对于冷加载。将此技术应用于10kb或更大的对象是一条很好的经验法则，但与通常的性能建议一样，在进行任何更改之前先测量实际效果。<br><img src="json.svg" alt=""><br><font size=2>JSON.parse(‘…’)相比于等价的JavaScript字面量，在解析，编译和执行上要<a href="https://github.com/GoogleChromeLabs/json-parse-benchmark" target="_blank" rel="noopener">快得多</a>— 不仅仅是V8（快1.7倍），所有主要的JavaScript引擎都如此</font></p><p>下面的视频将从02:10开始详细介绍性能差异的来源。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/ff4fgQxPaO0?start=130" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><font size=2>“使用JSON.parse加速应用程序“Mathias Bynens在2019年#ChromeDevSummit上提出的。</font></p><p>请参阅<a href="https://v8.dev/features/subsume-json#embedding-json-parse" target="_blank" rel="noopener">我们的JSON⊂ECMAScript功能解释器</a>以获取一个示例实现，该实现在给定任意对象的情况下生成一个有效的JavaScript程序，然后通过JSON.parse处理它</p><p>对于大量数据使用普通对象字面量还有一个额外的风险：它们可能被解析两次！</p><ol><li>第一次发生在字面量准备就绪时。</li><li>第二次发生在字面量被延迟解析时。</li></ol><p>第一次不能避免。幸运的是，第二次通过将对象字面量放在顶层或<a href="https://v8.dev/blog/preparser#pife" target="_blank" rel="noopener">PIFE</a>内，可以避免。</p><h4 id="对于重复访问的解析-编译呢？"><a href="#对于重复访问的解析-编译呢？" class="headerlink" title="对于重复访问的解析/编译呢？"></a>对于重复访问的解析/编译呢？</h4><p>V8的（字节）代码缓存优化可以帮助您。当第一次请求一个脚本时，Chrome会下载它并将其提供给V8进行编译。它还将文件存储在浏览器的磁盘缓存中。当第二次请求JS文件时，Chrome从浏览器缓存中获取该文件，并再次将其交给V8进行编译。但是，这一次，编译的代码被序列化，并作为元数据附加到缓存的脚本文件中。<br><img src="code-caching@2x.png" alt=""><br><font size=2>代码缓存在V8中工作方式的可视化</font></p><p>第三次，Chrome从缓存中获取文件和文件的元数据，并将两者都交给V8。V8反序列化元数据，可以跳过编译。如果前两次访问发生在72小时内，则代码缓存将起作用。如果使用ServiceWorker缓存脚本，Chrome同样也具有代码缓存功能。你可以在<a href="https://v8.dev/blog/code-caching-for-devs" target="_blank" rel="noopener">面向web开发人员的代码缓存</a>中阅读更多有关代码缓存的信息。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在2019年，下载和执行时间是加载脚本的主要瓶颈。你可以为首屏内容设计一个小的同步（内联）脚本，页面其余部分使用若干defer脚本。分解大bundle，这样你就只关注在用户需要的时候发送他们需要的代码，可以最大化V8的并行处理。</p><p>在移动设备上，由于网络、内存消耗和较慢CPU的执行时间，你应该发送更少的脚本。在延迟和可缓存性之间进行平衡，以最大限度地增加主线程之外可能发生的解析和编译工作量。</p><h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><ul><li><a href="https://v8.dev/blog/scanner" target="_blank" rel="noopener">极快的解析，第1部分：优化扫描</a></li><li><a href="https://v8.dev/blog/preparser" target="_blank" rel="noopener">极快的解析，第2部分：惰性解析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;原文→&quot;&gt;&lt;a href=&quot;#原文→&quot; class=&quot;headerlink&quot; title=&quot;原文→&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://v8.dev/blog/cost-of-javascript-2019&quot; target=&quot;_blank&quot; rel=&quot;no
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>理解Node.js事件循环阶段及其执行JavaScript代码的方式</title>
    <link href="https://100001.github.io/2020/07/23/Understanding-the-Node-js-event-loop-phases-and-how-it-executes-the-JavaScript-code/"/>
    <id>https://100001.github.io/2020/07/23/Understanding-the-Node-js-event-loop-phases-and-how-it-executes-the-JavaScript-code/</id>
    <published>2020-07-23T06:21:31.000Z</published>
    <updated>2020-07-23T08:25:14.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="5dlikj6szekblxlaseo4.png" alt=""></p><h4 id="原文→"><a href="#原文→" class="headerlink" title="原文→"></a><a href="https://dev.to/lunaticmonk/understanding-the-node-js-event-loop-phases-and-how-it-executes-the-javascript-code-1j9" target="_blank" rel="noopener">原文→</a></h4><p>我相信，如果您正在阅读本文，那么您一定已经听说了Node.js拥有著名的事件循环，它如何处理Node.js中的并发机制，以及它如何使Node.js成为事件驱动 I/O 的独特平台。 作为事件驱动的 I/O，执行的所有代码都是回调形式。 因此，重要的是要知道事件循环如何并且以何种顺序执行所有回调。 从这里开始，在此博客文章中，术语“事件循环”是指Node.js的事件循环。</p><p>从本质上讲，事件循环是一种在某些阶段进行迭代的机制。 您肯定听说过一个称为“事件循环迭代”的术语，该术语表示事件循环迭代贯穿其所有阶段。</p><p>在本文中，我将向您展示事件循环的底层架构及其所有阶段是什么，在哪个阶段中执行哪些代码，以及一些细节和最后一些示例，我认为它们将使您更好地理解关于事件循环的概念。</p><p>以下是事件循环按照其顺序迭代的所有阶段的图表：<br><img src="or3evh6lkjcg4zu1l300.png" alt=""><br>因此，事件循环是Node.js中的一种机制，它在一系列循环中进行迭代。 以下是事件循环迭代的各个阶段：</p><p>每个阶段都有一个 队列/堆，事件循环使用该 队列/堆 来 推送/存储 要执行的回调（Node.js中存在一个误解，即只有一个全局队列，在该队列中，回调被排队执行，这是不正确的）。</p><ol><li>Timers（计时器）：<br>JavaScript中的Timers回调（setTimeout，setInterval）保留在堆内存中，直到过期为止。 如果堆中有任何过期的Timers，则事件循环将使用与它们关联的回调，并以其延迟的升序开始执行它们，直到Timers队列为空。 但是，Timers回调的执行由事件循环的 Poll（轮询） 阶段控制（我们将在本文后面看到）。</li><li>Pending callbacks（待处理回调）：<br>在此阶段，事件循环执行与系统相关的回调（如果有）。 例如，假设您正在编写一个 Node 服务，而其他进程正在使用您要运行该进程的端口，则 Node 将抛出 ECONNREFUSED 错误，某些* nix系统可能由于操作系统正在处理其他一些任务而让回调等待执行。 因此，此类回调将被推送到待处理回调队列中以执行。</li><li>Idle/Prepare（空闲/准备）：<br>在此阶段，事件循环不执行任何操作。 它空闲，准备进入下一阶段。</li><li>Poll（轮询）：<br>这一阶段使Node.js变得独一无二。 在此阶段，事件循环会关注新的异步 I/O 回调。 除setTimeout，setInterval，setImmediate和close回调外，几乎所有回调都将执行。<br>基本上，事件循环在此阶段执行两件事：<ul><li>如果轮询阶段队列中已经有排队的回调，将执行它们，直到所有回调从轮询阶段回调队列中耗尽为止。</li><li>如果队列中没有回调，则事件循环将在轮询阶段停留一段时间。 现在，这个“一段时间”还取决于以下几点： <ul><li>如果setImmediate队列中存在要执行的回调，则事件循环在轮询阶段不会停留更长时间，而将进入下一个阶段，即Check / setImmediate。 再次，它将开始执行回调，直到Check / setImmediate阶段回调队列为空。</li><li>事件循环将从轮询阶段移出的第二种情况是，它知道有过期的Timers，这些Timers的回调正在等待执行。 在这种情况下，事件循环将移至下一阶段，即Check / setImmediate，然后移至Closing回调阶段，并最终从Timers阶段开始其下一次迭代。</li></ul></li></ul></li><li>Check / setImmediate：<br>在此阶段，事件循环从Check阶段的队列中获取回调，并开始一个接一个地执行直到队列为空。 当轮询阶段没有剩余要执行的回调并且轮询阶段变为空闲时，事件循环将进入此阶段。 通常，setImmediate的回调在此阶段执行。</li><li>Closing callbacks（关闭回调）：<br>在此阶段，事件循环执行与关闭事件关联的回调，例如 socket.on(‘close’，fn) 或 process.exit()。</li></ol><p>除了所有这些，还有一个微任务(microtask)队列，其中包含与process.nextTick相关的回调，我们将在稍后看到。</p><p>例子：<br>让我们从一个简单的示例开始，以了解如何执行以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>让我们回顾一下事件循环图，并结合其阶段说明，并尝试找出上述代码的输出：</p><p>当使用Node作为解释器执行时，以上代码的输出为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>事件循环进入Timers阶段并执行与上面的setTimeout相关的回调，然后进入随后的阶段（这些阶段并没有任何排队的回调），直到到达Check（setImmediate）阶段，在该阶段执行与它相关的回调函数。因此，输出期望的值。</p><p>注意：以上输出是可能被反转的，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>因为事件循环不能精确的在0毫秒时间内执行setTimeout(fn，0)的回调。而是在4-20毫秒的延迟后，执行回调。 （还记得吗？前面提到轮询阶段控制Timers回调的执行，因为它在轮询阶段等待一些I/O）。</p><p>现在，事件循环运行任何JavaScript代码时，都会发生两件事：</p><ol><li>当调用我们的JavaScript代码中的函数时，事件循环首先开始（而不是执行函数），然后将初始回调（即函数）注册到相应队列。</li><li>一旦它们注册，事件循环便进入其阶段，并开始迭代和执行回调，直到处理完所有回调为止。</li></ol><p>再举一个例子，或者说在Node.js中有一个误解，就是setTimeout(fn，0)总是在setImmediate之前执行，这是不对的！ 正如我们在上面的示例中看到的那样，事件循环最初处于Timers阶段，并且setTimeout定时器可能已过期，因此它先执行了，并且这种行为是不可预测的。 然而，并非总是如此，这完全取决于回调的数量，事件循环所处的阶段等等。</p><p>不管怎样，如果您执行以下操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'./xyz.txt'</span>, () =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">0</span>);</span><br><span class="line">    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>上面的代码将始终输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>让我们看看上面的代码是如何执行的：</p><ol><li>当我们调用main()函数时，事件循环首先执行而不是去执行回调。 我们遇到fs.readFile函数和已经注册的回调，并且该回调被推送到I/O阶段队列。 由于所有回调已注册了给定的函数，所以事件循环现在可以自由地开始执行回调。 因此，它从Timers开始遍历其各个阶段。 它在Timers和Pending回调阶段找不到任何内容。</li><li>当事件循环不断遍历其各个阶段并且看到文件读取操作已完成时，它将开始执行回调。</li></ol><p>请记住，事件循环开始执行fs.readFile的回调时，它处于I/O阶段，此后，它将移至Check（setImmediate）阶段。</p><ol><li>因此，Check阶段在当前运行的Timers阶段之前。 从而，在I/O阶段，setImmediate的回调将始终在setTimeout（fn，0）之前运行。</li></ol><p>（译者注：以上”请记住“后的内容比较难理解，我们可以把fs.readFile的回调执行那一刻，看做是在事件循环A的I/O阶段，执行完回调后，就先后注册了Timers（setTimeout）阶段 和 Check（setImmediate） 阶段的回调，然后事件循环A进入到Check阶段，这时因为刚刚注册过的setImmediate回调存在，所以先执行了setImmediate回调，然后再进入事件循环B的Timers阶段，去执行setTimeout。）</p><p>让我们再考虑一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">50</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'3'</span>));</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'4'</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>在我们了解事件循环如何执行此代码之前，需要了解一件事：</p><blockquote><p>process.nextTick属于微任务（microtasks），该微任务的优先级高于所有其他阶段，因此与之关联的回调在事件循环完成当前操作后立即执行。 这意味着，无论我们传递给process.nextTick的回调如何，事件循环都将完成其当前操作，然后从微任务队列执行回调，直到执行完。 队列执行完后，它将返回到其离开事件循环之前所处位置的阶段。</p></blockquote><ol><li>它首先检查微任务队列并在其中执行回调（在以上代码中为process.nextTick的回调）。</li><li>然后，它进入其第一阶段（Timers 阶段），其中50ms的计时器尚未到期。 因此，它前进到其他阶段。</li><li>然后，它进入 Check（setImmediate）阶段，在该阶段中看到计时器到期，并执行记录“ 3”的回调。</li><li>在事件循环的下一个迭代中，它看到50ms的计时器到期，因此记录为“ 1”。</li></ol><p>这是上面代码的输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>再看一个例子，这次我们将异步回调传递给我们的某一个process.nextTick。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">50</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'3'</span>));</span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>上面的代码片段的输出是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>现在，执行上述代码时将发生以下情况：</p><ol><li>所有回调均已注册并推送到其各自的队列中。</li><li>如前面的示例所示，由于微任务队列回调是首先执行的，因此将首先输出“ 2”。 同样，此时，第二个process.nextTick回调即setTimeout(将记录为“ 4”）已开始执行，并最终被推送到Timers阶段队列。</li><li>现在，事件循环进入其正常阶段并执行回调。 它进入的第一阶段是“Timers”。 可以看到50ms的计时器没有到期，因此可以进一步进入下一个阶段。</li><li>然后，它进入“Check（setImmediate）”阶段并执行setImmediate的回调，该回调最终输出“ 3”。</li><li>现在，事件循环的下一个迭代开始。 在事件循环中，事件循环返回到“计时器”阶段，它会同时遇到过期的计时器（即注册时分别为50ms和1000ms），并执行与之关联的回调，该回调首先输出“ 1”，然后再输出“ 4”。</li></ol><p>因此，如您所见，事件循环的各种状态，其阶段以及最重要的是process.nextTick及其功能。 它基本上将提供给它的回调放在微任务队列中，并优先执行。</p><p>最后一个例子和一个详细的例子，您还记得这篇博文开头的事件循环图吗？ 好吧，看看下面的代码。 我希望您弄清楚以下代码的输出是什么。 在代码之后，我对事件循环如何执行以下代码进行了直观介绍。 它将帮助您更好地理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>   <span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"> <span class="number">2</span></span><br><span class="line"> <span class="number">3</span>   <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="number">4</span>    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'1'</span>), <span class="number">0</span>);</span><br><span class="line"> <span class="number">5</span>    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'2'</span>));</span><br><span class="line"> <span class="number">6</span></span><br><span class="line"> <span class="number">7</span>    fs.readFile(<span class="string">'./xyz.txt'</span>, (err, buff) =&gt; &#123;</span><br><span class="line"> <span class="number">8</span>     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="number">9</span>      <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line"><span class="number">10</span>     &#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span>     process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="number">13</span>      <span class="built_in">console</span>.log(<span class="string">'process.nextTick'</span>);</span><br><span class="line"><span class="number">14</span>     &#125;);</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span>     setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'4'</span>));</span><br><span class="line"><span class="number">17</span>    &#125;);</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span>    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'5'</span>));</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="number">22</span>     process.on(<span class="string">'exit'</span>, (code) =&gt; &#123;</span><br><span class="line"><span class="number">23</span>      <span class="built_in">console</span>.log(<span class="string">`close callback`</span>);</span><br><span class="line"><span class="number">24</span>     &#125;);</span><br><span class="line"><span class="number">25</span>    &#125;, <span class="number">1100</span>);</span><br><span class="line"><span class="number">26</span>   &#125;</span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span>   main();</span><br></pre></td></tr></table></figure><p>以下gif指示事件循环如何执行上述代码：</p><p>注意：</p><ol><li>以下gif中指示的队列中的数字是以上代码中的回调的行号。</li><li>由于我的重点是事件循环阶段如何执行代码，因此我没有在gif中插入Idle / Prepare阶段，因为它仅由事件循环在内部使用。<br><img src="xqave9c6288hgekmmvq5.gif" alt=""><br>以上代码将输出：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">process.nextTick</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">close callback</span><br></pre></td></tr></table></figure>或者，也可以是（回忆第一个例子）：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">process.nextTick</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">close callback</span><br></pre></td></tr></table></figure></li></ol><h4 id="其余"><a href="#其余" class="headerlink" title="其余:"></a>其余:</h4><h5 id="微任务-Microtasks"><a href="#微任务-Microtasks" class="headerlink" title="微任务(Microtasks):"></a>微任务(Microtasks):</h5><p>因此，Node.js中有一个东西或者说是在v8中准确的叫做“微任务（Microtasks）”。明确地说，微任务不是事件循环的一部分，而是v8的一部分。在本文前面，您可能已经阅读了有关process.nextTick的信息。 JavaScript中有一些任务属于微任务，分别是process.nextTick，Promise.resolve等。</p><p>这些任务的优先级高于其他任务/阶段，这意味着事件循环在结束其当前操作之后，将执行微任务队列的所有回调，直到执行完毕，然后恢复到其离开的阶段继续循环。</p><p>因此，每当Node.js遇到上面定义的任何微任务时，它都会将关联的回调推送到微任务队列并立即开始执行（对微任务进行优先级排序）并执行所有回调，直到队列完全执行完毕。</p><p>话虽这么说，如果您在微任务队列中放置了很多回调，您可能最终会饿死事件循环，因为它永远不会进入任何其他阶段。</p><h5 id="宏任务-Macrotasks"><a href="#宏任务-Macrotasks" class="headerlink" title="宏任务(Macrotasks):"></a>宏任务(Macrotasks):</h5><p>诸如setTimeout，setInterval，setImmediate，requestAnimationFrame，I / O，UI渲染或其他I / O回调之类的任务都属于宏任务（Macrotasks）。 他们没有事件循环优先级之类的东西。 回调是根据事件循环阶段执行的。</p><h4 id="事件循环Tick"><a href="#事件循环Tick" class="headerlink" title="事件循环Tick:"></a>事件循环Tick:</h4><p>我们说事件循环在其所有阶段迭代一次（事件循环的一次迭代）即是一次tick。<br>事件循环tick频率高和tick持续时间短（一次迭代所花费的时间）表示健康的事件循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;5dlikj6szekblxlaseo4.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;原文→&quot;&gt;&lt;a href=&quot;#原文→&quot; class=&quot;headerlink&quot; title=&quot;原文→&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://dev.to/lu
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
